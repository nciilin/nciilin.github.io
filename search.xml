<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>JSONP_跨域</title>
      <link href="/2019/07/19/JSONP_%E8%B7%A8%E5%9F%9F/"/>
      <url>/2019/07/19/JSONP_%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h2><p>同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。<br><strong>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</strong><br>所谓”同源”指的是”三个相同”。</p><ul><li>协议相同</li><li>域名相同</li><li>端口相同</li></ul><h2 id="跨域有几种实现形式"><a href="#跨域有几种实现形式" class="headerlink" title="跨域有几种实现形式"></a>跨域有几种实现形式</h2><p>跨域有4种实现形式。</p><ol><li>jsonp</li><li>CORS</li><li>降域</li><li>postMessage</li></ol><h2 id="什么是-JSONP？"><a href="#什么是-JSONP？" class="headerlink" title="什么是 JSONP？"></a>什么是 JSONP？</h2><p>jsonp是便于客户端使用数据，逐渐形成了一种非正式传输协议。jsonp的核心则是动态添加<code>&lt;script&gt;</code>标签来调用服务器提供的js脚本。</p><h2 id="JSONP-为什么不支持-POST"><a href="#JSONP-为什么不支持-POST" class="headerlink" title="JSONP 为什么不支持 POST"></a>JSONP 为什么不支持 POST</h2><ol><li>因为JSONP是通过动态<code>&lt;script&gt;</code>创建的。</li><li>使用动态<code>&lt;script&gt;</code>后只能使用GET请求，不能使用POST请求。</li></ol><h2 id="什么是CORS"><a href="#什么是CORS" class="headerlink" title="什么是CORS"></a>什么是CORS</h2><p>CORS 全称是<strong>跨域资源共享</strong>（<code>Cross-Origin Resource Sharing</code>），是一种 <em>AJAX</em> 跨域请求资源的方式，当你使用 <strong>XMLHttpRequest</strong> 发送请求时，浏览器发现该请求不符合同源策略，会给该请求加一个请求头：Origin，后台进行一系列处理，如果确定接受请求则在返回结果中加入一个响应头：<code>Access-Control-Allow-Origin</code>; 浏览器判断该相应头中是否包含 Origin 的值.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//  AJAX请求</span><br><span class="line">let request = new XMLHttpRequest()</span><br><span class="line">  request.open(&apos;GET&apos;, &apos;/xxx&apos;)</span><br><span class="line">  request.send()</span><br><span class="line">  request.onreadystatechange(() =&gt; &#123;</span><br><span class="line">    if (request.readyState === 4) &#123;</span><br><span class="line">      if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) &#123;</span><br><span class="line">        let string = request.responseText</span><br><span class="line">        let object = JSON.parse(string)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if(request.status &gt;= 400) &#123;</span><br><span class="line">      console.log(&apos;请求失败&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h2 id="AJAX-的所有功能"><a href="#AJAX-的所有功能" class="headerlink" title="AJAX 的所有功能"></a>AJAX 的所有功能</h2><ul><li>客户端的JS发起请求（浏览器上的）</li><li>服务端的JS发送响应（Node.js上的）</li></ul><ol><li><p>JS 可以设置任意请求 header 吗<br>第一部分 request.open(‘get’, ‘/xxx’)<br>第二部分 request.setRequestHeader(‘content-type’,’x-www-form-urlencoded’)<br>第四部分 request.send(‘a=1&amp;b=2’)</p></li><li><p>JS 可以获取任意响应 header 吗？<br>第一部分 request.status / request.statusText<br>第二部分 request.getResponseHeader() / request.getAllResponseHeaders()<br>第四部分 request.responseText</p></li></ol><h2 id="使用JQuery的异步请求"><a href="#使用JQuery的异步请求" class="headerlink" title="使用JQuery的异步请求"></a>使用JQuery的异步请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">JQuery.ajax(&#123;url, method, body, success, fail&#125;) &#123;</span><br><span class="line">    let request = new XMLHttpRequest()</span><br><span class="line">    request.open(method, url)</span><br><span class="line">    request.onreadystatechange = () =&gt; &#123;</span><br><span class="line">        if (request.readyState === 4) &#123;</span><br><span class="line">            if(request.status &gt;= 200 &amp;&amp; request.status &lt; 300) &#123;</span><br><span class="line">                success.call(undefined, request.responseText)</span><br><span class="line">            &#125; else if (request.status &gt; 400) &#123;</span><br><span class="line">                fail.call(undefined, request)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    request.send(body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Promise规则封装-jQuery-ajax"><a href="#使用Promise规则封装-jQuery-ajax" class="headerlink" title="使用Promise规则封装 jQuery.ajax"></a>使用Promise规则封装 jQuery.ajax</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = function(&#123;url, method&#125;) &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    let request = new XMLHttpRequest()</span><br><span class="line">    request.open(method, url)</span><br><span class="line">    request.onreadystatechange = () =&gt; &#123;</span><br><span class="line">      if (request.readyState === 4) &#123;</span><br><span class="line">          if(request.status &gt;= 200 &amp;&amp; request.status &lt; 300) &#123;</span><br><span class="line">              resolve.call(undefined, request.responseText)</span><br><span class="line">          &#125; else if (request.status &gt; 400) &#123;</span><br><span class="line">              reject.call(undefined, request)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    request.send()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>面试题</title>
      <link href="/2019/07/15/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/07/15/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="请写出一个符合-W3C-规范的-HTML-文件，要求"><a href="#请写出一个符合-W3C-规范的-HTML-文件，要求" class="headerlink" title="请写出一个符合 W3C 规范的 HTML 文件，要求"></a>请写出一个符合 W3C 规范的 HTML 文件，要求</h2><ol><li>页面标题为「我的页面」</li><li>页面中引入了一个外部 CSS 文件，文件路径为 /style.css</li><li>页面中引入了另一个外部 CSS 文件，路径为 /print.css，该文件仅在打印时生效</li><li>页面中引入了另一个外部 CSS 文件，路径为 /mobile.css，该文件仅在设备宽度小于 500 像素时生效</li><li>页面中引入了一个外部 JS 文件，路径为 /main.js</li><li>页面中引入了一个外部 JS 文件，路径为 /gbk.js，文件编码为 GBK</li><li>页面中有一个 SVG 标签，SVG 里面有一个直径为 100 像素的圆圈，颜色随意</li><li>注意题目中的路径</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;我的页面&lt;/title&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;./style.css&quot;&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;./print.css&quot; media=&quot;print&quot;&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;./mobile.css&quot; media=&quot;screen and (max-width:500px)&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;svg width=&quot;200px&quot; height=&quot;200px&quot;&gt;</span><br><span class="line">      &lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;50&quot; fill=&quot;yellow&quot;/&gt;</span><br><span class="line">  &lt;/svg&gt;</span><br><span class="line">&lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./gbk.js&quot; charset=&quot;GBK&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="移动端是怎么做适配的？"><a href="#移动端是怎么做适配的？" class="headerlink" title="移动端是怎么做适配的？"></a>移动端是怎么做适配的？</h2><ol><li>meta viewport</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>媒体查询</li></ol><p>如果满足媒体查询中的条件，设置生效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@media (min-width: 960px) &#123;</span><br><span class="line"></span><br><span class="line">​    body &#123;</span><br><span class="line"></span><br><span class="line">​        background: red</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// 如果媒体查询满足不小于960px的条件，则body背景色变红色</span><br></pre></td></tr></table></figure></p><ol start="3"><li>动态 rem 方案</li></ol><p>移动端自适应rem</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">        var scale = 1 / window.devicePixelRatio;</span><br><span class="line"></span><br><span class="line">        document.write(`&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=$&#123;scale&#125;, maximum-scale=$&#123;scale&#125;, minimum-scale=$&#123;scale&#125;&quot;&gt;`)</span><br><span class="line"></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line"></span><br><span class="line">        var width = document.documentElement.clientWidth / window.devicePixelRatio;</span><br><span class="line"></span><br><span class="line">        var css = `</span><br><span class="line"></span><br><span class="line">            html&#123;</span><br><span class="line"></span><br><span class="line">                font-size: $&#123;width / 10 * window.devicePixelRatio&#125;px;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        `</span><br><span class="line"></span><br><span class="line">        document.write(`&lt;style&gt;$&#123;css&#125;&lt;/style&gt;`)</span><br><span class="line"></span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><p><a href="https://bloglive.top/demo/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%87%AA%E9%80%82%E5%BA%94rem/index.html" target="_blank" rel="noopener">移动端rem</a></p><h2 id="实现圆角矩形和阴影怎么做"><a href="#实现圆角矩形和阴影怎么做" class="headerlink" title="实现圆角矩形和阴影怎么做?"></a>实现圆角矩形和阴影怎么做?</h2><ol><li>圆角矩形(<strong>border-radius</strong>)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-radius: 25px</span><br></pre></td></tr></table></figure></li></ol><p>2, 阴影(<strong>box-shadow</strong>)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box-shadow: 3px 4px 5px 0px rgba(0,0,0,0.75);</span><br></pre></td></tr></table></figure></p><p><a href="http://js.jirengu.com/qetecesiyi/2/edit" target="_blank" rel="noopener">demo</a></p><h2 id="什么是闭包，闭包的用途是什么？"><a href="#什么是闭包，闭包的用途是什么？" class="headerlink" title="什么是闭包，闭包的用途是什么？"></a>什么是闭包，闭包的用途是什么？</h2><p><strong>函数和函数内部能够访问外部变量的环境，就是闭包。</strong><br>闭包的用途：</p><pre><code>1. 隐藏一个变量。2. 函数作用域下，保护内部变量不受外部影响的机制。</code></pre><h2 id="call、apply、bind-的用法分别是什么？"><a href="#call、apply、bind-的用法分别是什么？" class="headerlink" title="call、apply、bind 的用法分别是什么？"></a>call、apply、bind 的用法分别是什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun.call(thisArg, arg1, arg2, ...)</span><br><span class="line">func.apply(thisArg, [argsArray])</span><br><span class="line">function.bind(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//Demo with javascript .call()</span><br><span class="line"></span><br><span class="line">var obj = &#123;name:&quot;Niladri&quot;&#125;;</span><br><span class="line"></span><br><span class="line">var greeting = function(a,b,c)&#123;</span><br><span class="line">    return &quot;welcome &quot;+this.name+&quot; to &quot;+a+&quot; &quot;+b+&quot; in &quot;+c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(greeting.call(obj,&quot;Newtown&quot;,&quot;KOLKATA&quot;,&quot;WB&quot;));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//Demo with javascript .apply()</span><br><span class="line"></span><br><span class="line">var obj = &#123;name:&quot;Niladri&quot;&#125;;</span><br><span class="line"></span><br><span class="line">var greeting = function(a,b,c)&#123;</span><br><span class="line">    return &quot;welcome &quot;+this.name+&quot; to &quot;+a+&quot; &quot;+b+&quot; in &quot;+c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// array of arguments to the actual function</span><br><span class="line">var args = [&quot;Newtown&quot;,&quot;KOLKATA&quot;,&quot;WB&quot;];  </span><br><span class="line">console.log(&quot;Output using .apply() below &quot;)</span><br><span class="line">console.log(greeting.apply(obj,args));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//Use .bind() javascript</span><br><span class="line"></span><br><span class="line">var obj = &#123;name:&quot;Niladri&quot;&#125;;</span><br><span class="line"></span><br><span class="line">var greeting = function(a,b,c)&#123;</span><br><span class="line">    return &quot;welcome &quot;+this.name+&quot; to &quot;+a+&quot; &quot;+b+&quot; in &quot;+c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//creates a bound function that has same body and parameters </span><br><span class="line">var bound = greeting.bind(obj); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.dir(bound); ///returns a function</span><br><span class="line"></span><br><span class="line">console.log(&quot;Output using .bind() below &quot;);</span><br><span class="line"></span><br><span class="line">console.log(bound(&quot;Newtown&quot;,&quot;KOLKATA&quot;,&quot;WB&quot;)); //call the bound function</span><br></pre></td></tr></table></figure><h2 id="请说出至少-8-个-HTTP-状态码，并描述各状态码的意义。"><a href="#请说出至少-8-个-HTTP-状态码，并描述各状态码的意义。" class="headerlink" title="请说出至少 8 个 HTTP 状态码，并描述各状态码的意义。"></a>请说出至少 8 个 HTTP 状态码，并描述各状态码的意义。</h2><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><ol><li>1xx消息<br>代表请求已被接受，需要继续处理</li><li>2xx成功<br>代表请求已成功被服务器接收、理解、并接受</li><li>3xx重定向<br>代表需要客户端采取进一步的操作才能完成请求</li><li>4xx客户端错误<br>代表了客户端看起来可能发生了错误，妨碍了服务器的处理</li><li>5xx服务器错误<br>表示服务器无法完成明显有效的请求</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">200---(成功) 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</span><br><span class="line">201---(已创建) 请求成功并且服务器创建了新的资源。</span><br><span class="line">301---(永久移动)请求的网页已永久移动到新位置.服务器返回此响应(对 GET 或 HEAD 请求的响应)时,会自动将请求者转到新位置</span><br><span class="line">304---(未修改)自从上次请求后,请求的网页未修改过.服务器返回此响应时,不会返回网页内容</span><br><span class="line">403---(禁止)服务器拒绝请求</span><br><span class="line">404---(未找到)服务器找不到请求的网页</span><br><span class="line">500---(服务器内部错误)服务器遇到错误,无法完成请求</span><br><span class="line">503---(服务不可用)服务器目前无法使用(由于超载或停机维护)</span><br></pre></td></tr></table></figure><h2 id="请写出一个-HTTP-post-请求的内容，包括四部分。其中"><a href="#请写出一个-HTTP-post-请求的内容，包括四部分。其中" class="headerlink" title="请写出一个 HTTP post 请求的内容，包括四部分。其中"></a>请写出一个 HTTP post 请求的内容，包括四部分。其中</h2><ol><li>第四部分的内容是 username=ff&amp;password=123</li><li>第二部分必须含有 Content-Type 字段</li><li>请求的路径为 /path</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 POST /path  HTTP/1.1</span><br><span class="line">2 key: value</span><br><span class="line">2 key: value</span><br><span class="line">2 Content-Type: application/x-www-form-urlencoded</span><br><span class="line">3</span><br><span class="line">4 username=ff&amp;password=123</span><br></pre></td></tr></table></figure><h2 id="请说出至少三种排序的思路，这三种排序的时间复杂度分别为"><a href="#请说出至少三种排序的思路，这三种排序的时间复杂度分别为" class="headerlink" title="请说出至少三种排序的思路，这三种排序的时间复杂度分别为"></a>请说出至少三种排序的思路，这三种排序的时间复杂度分别为</h2><ol><li>O(n*n)</li><li>O(n log2 n)</li><li>O(n + max) </li></ol><h3 id="O-n-n-冒泡排序"><a href="#O-n-n-冒泡排序" class="headerlink" title="O(n*n) 冒泡排序"></a>O(n*n) 冒泡排序</h3><p>冒泡排序，重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    for (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        for (var j = 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j+1]) &#123;        // 相邻元素两两对比</span><br><span class="line">                var temp = arr[j+1];        // 元素交换</span><br><span class="line">                arr[j+1] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="O-n-log2-n-快速排序"><a href="#O-n-log2-n-快速排序" class="headerlink" title="O(n log2 n)快速排序"></a>O(n log2 n)快速排序</h3><p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为较小和较大的2个子序列，然后递归地排序两个子序列。</p><pre><code>步骤为：1. 挑选基准值：从数列中挑出一个元素，称为“基准”（pivot），2. 分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成，3.  递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。</code></pre><h3 id="O-n-max-基数排序"><a href="#O-n-max-基数排序" class="headerlink" title="O(n + max) 基数排序"></a>O(n + max) 基数排序</h3><p>是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。</p><h2 id="一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？"><a href="#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？"></a>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h2><ol><li><p>DNS解析<br>一开始输入URL地址，如<code>www.baidu.com</code>，浏览器可能会进行一些预处理。浏览器回对URL进行检查，首先判断协议、判断URL的安全性… 最后进行DNS解析。</p><blockquote><p>浏览器缓存 – 浏览器会缓存DNS记录一段时间<br>系统缓存 – 从hosts文件里查找是否有该域名和对应IP<br>路由器缓存 – 一般路由器也会缓存域名信息<br>ISP DNS 缓存 – 比如到电信的DNS上查找缓存<br>如果都没有找到，则向根域名服务器查找域名对应IP，根域名服务器把请求转发到下一级，直到找到IP</p></blockquote></li><li><p>TCP链接<br><strong>然后建立TCP连接 – 三次握手</strong></p></li></ol><ul><li>主机向服务器发送一个建立连接的请求（您好，我想认识您）</li><li>服务器接到请求后发送同意连接的信号（好的，很高兴认识您）</li><li>主机接到同意连接的信号后，再次向服务器发送了确认信号（我也很高兴认识您），自此，主机与服务器两者建立了连接</li></ul><ol start="3"><li>发送HTTP请求</li></ol><ul><li>浏览器根据 URL 内容生成 HTTP 请求，请求中包含请求文件的位置、请求文件的方式等等</li><li>服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件</li><li>服务器将得到的 HTML 文件发送给浏览器</li><li>在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页</li><li>在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript等文件，过程同请求 HTML</li></ul><ol start="4"><li><p>服务器处理请求并返回HTTP报文<br>服务器的端口接收到请求报文，开始分析处理报文，查询服务器内是否存在符合请求要求的路径以及文件，返回响应报文；如果不存在此路径或者文件，则返回响应报文，状态码404等消息；如果有，则发送响应报文，包括HTTP协议、状态码200、响应报头、响应内容等；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 响应成功</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Bdpagetype: 2</span><br><span class="line">Bdqid: 0x8bf910690013ab7d</span><br><span class="line">Cache-Control: private</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Type: text/html;charset=utf-8</span><br><span class="line">Date: Mon, 15 Jul 2019 14:51:28 GMT</span><br><span class="line">Expires: Mon, 15 Jul 2019 14:51:27 GMT</span><br><span class="line">Server: BWS/1.1</span><br><span class="line">Set-Cookie: BDSVRTM=227; path=/</span><br><span class="line">Set-Cookie: BD_HOME=1; path=/</span><br><span class="line">Set-Cookie: H_PS_PSSID=1458_21103_20698_29522_29519_29237_28518_29098_28838_29220; path=/; domain=.baidu.com</span><br><span class="line">Strict-Transport-Security: max-age=172800</span><br><span class="line">X-Ua-Compatible: IE=Edge,chrome=1</span><br><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure></li><li><p>浏览器解析并渲染页面</p><blockquote><p>解析 HTML 标签, 构建 DOM 树<br>解析 CSS 标签, 构建 CSSOM 树<br>把 DOM 和 CSSOM 组合成 渲染树 (render tree)<br>在渲染树的基础上进行布局(layout), 计算每个节点的几何结构<br>把每个节点绘制到屏幕上 (painting)</p></blockquote></li><li>连接结束</li></ol><h2 id="实现数组去重？"><a href="#实现数组去重？" class="headerlink" title="实现数组去重？"></a>实现数组去重？</h2><ol><li>相邻元素去重(ES5)<br>这种方法首先调用了数组的排序方法sort()，然后根据排序后的结果进行遍历及相邻元素比对，如果相等则跳过改元素，直到遍历结束</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var array = [1,5,2,3,4,2,3,1,3,4]</span><br><span class="line"></span><br><span class="line">function unique(array) &#123;</span><br><span class="line">  if(!Array.isArray(array)) &#123;</span><br><span class="line">    console.log(&apos;type error!&apos;)</span><br><span class="line">    return </span><br><span class="line">  &#125;</span><br><span class="line">  array = array.sort()</span><br><span class="line">  let res = []</span><br><span class="line">  for(let i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    if(array[i] !== array[i - 1]) &#123;</span><br><span class="line">      res.push(array[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unique(array)</span><br></pre></td></tr></table></figure><ol start="2"><li>set与解构赋值去重(ES6)<br>ES6中新增了数据类型set，set的一个最大的特点就是数据不重复。Set函数可以接受一个数组（或类数组对象）作为参数来初始化，利用该特性也能做到给数组去重</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var array = [1,5,2,3,4,2,3,1,3,4]</span><br><span class="line"></span><br><span class="line">function unique(array) &#123;</span><br><span class="line">  if(!Array.isArray(array)) &#123;</span><br><span class="line">    console.log(&apos;type error!&apos;)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  return [...new Set(array)].sort()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unique(array)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>JS操作DOM常用API</title>
      <link href="/2019/07/07/JS%E6%93%8D%E4%BD%9CDOM%E5%B8%B8%E7%94%A8API/"/>
      <url>/2019/07/07/JS%E6%93%8D%E4%BD%9CDOM%E5%B8%B8%E7%94%A8API/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h3><p>Node类型中，我们最常用的就是element，text，attribute，comment，document，document_fragment这几种类型。</p><h3 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h3><p>Element提供了对元素标签名，子节点和特性的访问，我们常用HTML元素比如div，span，a等标签就是element中的一种。</p><p><strong>特性：</strong><br>(1) <code>nodeType为1</code><br>(2) <code>nodeName为元素标签名，tagName也是返回标签名</code><br>(3) <code>nodeValue为null</code><br>(4) <code>parentNode可能是Document或Element</code><br>(5) <code>子节点可能是Element，Text，Comment，Processing_Instruction，CDATASection或EntityReference</code></p><h3 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h3><p>Text表示文本节点，它包含的是纯文本内容，不能包含html代码，但可以包含转义后的html代码。<br><strong>特性：</strong><br>(1) <code>nodeType为3</code><br>(2) <code>nodeName为#text</code><br>(3) <code>nodeValue为文本内容</code><br>(4) <code>parentNode是一个Element</code><br>(5) <code>没有子节点</code></p><h3 id="Attr类型"><a href="#Attr类型" class="headerlink" title="Attr类型"></a>Attr类型</h3><p>Attr类型表示元素的特性，相当于元素的attributes属性中的节点。<br><strong>特性：</strong><br>(1) <code>nodeType值为2</code><br>(2) <code>nodeName是特性的名称</code><br>(3) <code>nodeValue是特性的值</code><br>(4) <code>parentNode为null</code></p><h3 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a>Comment类型</h3><p>Comment表示HTML文档中的注释。<br><strong>特性：</strong><br>(1) <code>nodeType为8</code><br>(2) <code>nodeName为#comment</code><br>(3) <code>nodeValue为注释的内容</code><br>(4) <code>parentNode可能是Document或Element</code><br>(5) <code>没有子节点</code></p><h3 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h3><p>Document表示文档，在浏览器中，document对象是HTMLDocument的一个实例，表示整个页面，它同时也是window对象的一个属性。<br><strong>特性：</strong><br>(1) <code>nodeType为9</code><br>(2) <code>nodeName为#document</code><br>(3) <code>nodeValue为null</code><br>(4) <code>parentNode为null</code><br>(5) <code>子节点可能是一个DocumentType或Element</code></p><h3 id="DocumentFragment类型"><a href="#DocumentFragment类型" class="headerlink" title="DocumentFragment类型"></a>DocumentFragment类型</h3><p>DocumentFragment是所有节点中唯一一个没有对应标记的类型，它表示一种轻量级的文档，可能当作一个临时的仓库用来保存可能会添加到文档中的节点。<br><strong>特性：</strong><br>(1) <code>nodeType为11</code><br>(2) <code>nodeName为#document-fragment</code><br>(3) <code>nodeValue为null</code><br>(4) <code>parentNode为null</code></p><h2 id="节点创建型api"><a href="#节点创建型api" class="headerlink" title="节点创建型api"></a>节点创建型api</h2><h3 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h3><p>通过传入指定的一个标签名来创建一个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var div = document.createElement(&quot;div&quot;);</span><br></pre></td></tr></table></figure></p><h3 id="createTextNode"><a href="#createTextNode" class="headerlink" title="createTextNode"></a>createTextNode</h3><p>创建一个文本节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var textNode = document.createTextNode(&quot;一个TextNode&quot;);</span><br></pre></td></tr></table></figure></p><h3 id="cloneNode"><a href="#cloneNode" class="headerlink" title="cloneNode"></a>cloneNode</h3><p>返回调用方法的节点的一个副本，它接收一个bool参数，用来表示是否复制子元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var parent = document.getElementById(&quot;parentElement&quot;);</span><br><span class="line">var parent2 = parent.cloneNode(true);// 传入true</span><br><span class="line">parent2.id = &quot;parent2&quot;;</span><br></pre></td></tr></table></figure></p><h3 id="createDocumentFragment"><a href="#createDocumentFragment" class="headerlink" title="createDocumentFragment"></a>createDocumentFragment</h3><p>用来创建一个DocumentFragment<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fragment = document.createDocumentFragment();</span><br></pre></td></tr></table></figure></p><h3 id="创建型API总结"><a href="#创建型API总结" class="headerlink" title="创建型API总结"></a>创建型API总结</h3><ol><li><p>它们创建的节点只是一个孤立的节点，要通过<code>appendChild</code>添加到文档中</p></li><li><p>cloneNode要注意如果被复制的节点是否包含子节点以及事件绑定等问题</p></li><li><p>使用createDocumentFragment来解决添加大量节点时的性能问题</p></li></ol><h2 id="页面修改型API"><a href="#页面修改型API" class="headerlink" title="页面修改型API"></a>页面修改型API</h2><p>修改页面内容的api主要包括：<strong>appendChild，insertBefore，removeChild，replaceChild</strong>。</p><h3 id="appendChild"><a href="#appendChild" class="headerlink" title="appendChild"></a>appendChild</h3><p>child节点将会作为parent节点的最后一个子节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.appendChild(child);</span><br></pre></td></tr></table></figure><h3 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore"></a>insertBefore</h3><p>insertBefore用来添加一个节点到一个参照节点之前<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parentNode.insertBefore(newNode,refNode);</span><br></pre></td></tr></table></figure></p><h3 id="removeChild"><a href="#removeChild" class="headerlink" title="removeChild"></a>removeChild</h3><p>删除指定的子节点并返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var deletedChild = parent.removeChild(node);</span><br></pre></td></tr></table></figure></p><h3 id="replaceChild"><a href="#replaceChild" class="headerlink" title="replaceChild"></a>replaceChild</h3><p>replaceChild用于使用一个节点替换另一个节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.replaceChild(newChild,oldChild);</span><br></pre></td></tr></table></figure></p><h2 id="页面修改型API总结"><a href="#页面修改型API总结" class="headerlink" title="页面修改型API总结"></a>页面修改型API总结</h2><ol><li><p>不管是新增还是替换节点，如果新增或替换的节点是原本存在页面上的，则其原来位置的节点将被移除，也就是说同一个节点不能存在于页面的多个位置</p></li><li><p>节点本身绑定的事件会不会消失，会一直保留着。</p></li></ol><h2 id="节点查询型API"><a href="#节点查询型API" class="headerlink" title="节点查询型API"></a>节点查询型API</h2><h3 id="document-getElementById"><a href="#document-getElementById" class="headerlink" title="document.getElementById"></a>document.getElementById</h3><p>根据元素id返回元素，返回值是Element类型，如果不存在该元素，则返回null。<br><strong>注意：</strong></p><ol><li><p>元素的Id是大小写敏感的，一定要写对元素的id</p></li><li><p>HTML文档中可能存在多个id相同的元素，则返回第一个元素</p></li><li><p>只从文档中进行搜索元素，如果创建了一个元素并指定id，但并没有添加到文档中，则这个元素是不会被查找到的</p></li></ol><h3 id="document-getElementsByTagName"><a href="#document-getElementsByTagName" class="headerlink" title="document.getElementsByTagName"></a>document.getElementsByTagName</h3><p>根据元素标签名获取元素，返回一个即时的HTMLCollection类型<br><strong>注意：</strong></p><ol><li><p>如果要对HTMLCollection集合进行循环操作，最好将其长度缓存起来，因为每次循环都会去计算长度，暂时缓存起来可以提高效率</p></li><li><p>如果没有存在指定的标签，该接口返回的不是null，而是一个空的HTMLCollection</p></li><li><p>“*”表示所有标签</p></li></ol><h3 id="document-getElementsByName"><a href="#document-getElementsByName" class="headerlink" title="document.getElementsByName"></a>document.getElementsByName</h3><p>主要是通过指定的name属性来获取元素，它返回一个即时的NodeList对象。<br><strong>注意：</strong></p><ol><li><p>返回对象是一个即时的NodeList，它是随时变化的</p></li><li><p>在HTML元素中，并不是所有元素都有name属性，比如div是没有name属性的，但是如果强制设置div的name属性，它也是可以被查找到的</p></li><li><p>在IE中，如果id设置成某个值，然后传入getElementsByName的参数值和id值一样，则这个元素是会被找到的，所以最好不好设置同样的值给id和name</p></li></ol><h3 id="document-getElementsByClassName"><a href="#document-getElementsByClassName" class="headerlink" title="document.getElementsByClassName"></a>document.getElementsByClassName</h3><p>这个API是根据元素的class返回一个即时的HTMLCollection<br><code>var elements = document.getElementsByClassName(names);</code><br><strong>注意：</strong></p><ol><li><p>返回结果是一个即时的HTMLCollection，会随时根据文档结构变化</p></li><li><p>IE9以下浏览器不支持</p></li><li><p>如果要获取2个以上classname，可传入多个classname，每个用空格相隔</p></li></ol><h3 id="document-querySelector和document-querySelectorAll"><a href="#document-querySelector和document-querySelectorAll" class="headerlink" title="document.querySelector和document.querySelectorAll"></a>document.querySelector和document.querySelectorAll</h3><p>这两个api很相似，通过css选择器来查找元素，注意选择器要符合CSS选择器的规则。<br><code>document.querySelector</code>返回<strong>第一个匹配的元素</strong>，如果没有匹配的元素，则返回null。<br><code>document.querySelectorAll</code>的不同之处在于它返回的是<strong>所有匹配的元素</strong>，而且可以匹配多个选择符<br><strong>注意：</strong></p><ol><li><p>querySelectorAll也是通过深度优先搜索，搜索的元素顺序和选择器的顺序无关</p></li><li><p>返回的是一个非即时的NodeList，也就是说结果不会随着文档树的变化而变化</p></li></ol><h2 id="节点关系型api"><a href="#节点关系型api" class="headerlink" title="节点关系型api"></a>节点关系型api</h2><h3 id="父关系型api"><a href="#父关系型api" class="headerlink" title="父关系型api"></a>父关系型api</h3><p><code>parentNode</code>：每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，Document或DocumentFragment。<br><code>parentElement</code>：返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element，如果不是，则返回null</p><h3 id="兄弟关系型api"><a href="#兄弟关系型api" class="headerlink" title="兄弟关系型api"></a>兄弟关系型api</h3><p><code>previousSibling</code>：节点的前一个节点，如果该节点是第一个节点，则为null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下。<br><code>previousElementSibling</code>：返回前一个元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持。<br><code>nextSibling</code>：节点的后一个节点，如果该节点是最后一个节点，则为null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下。<br><code>nextElementSibling</code>：返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持。</p><h3 id="子关系型api"><a href="#子关系型api" class="headerlink" title="子关系型api"></a>子关系型api</h3><p><code>childNodes</code>：返回一个即时的NodeList，表示元素的子节点列表，子节点可能会包含文本节点，注释节点等。<br><code>children</code>：一个即时的HTMLCollection，子节点都是Element，IE9以下浏览器不支持。<br><code>firstNode</code>：第一个子节点<br><code>lastNode</code>：最后一个子节点<br><code>hasChildNodes</code>方法：可以<strong>用来判断是否包含子节点。</strong></p><h3 id="元素属性型api"><a href="#元素属性型api" class="headerlink" title="元素属性型api"></a>元素属性型api</h3><h3 id="setAttribute"><a href="#setAttribute" class="headerlink" title="setAttribute"></a>setAttribute</h3><p>根据名称和值修改元素的特性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.setAttribute(name, value);</span><br></pre></td></tr></table></figure><h3 id="getAttribute"><a href="#getAttribute" class="headerlink" title="getAttribute"></a>getAttribute</h3><p>返回指定的特性名相应的特性值，如果不存在，则返回null或空字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var value = element.getAttribute(&quot;id&quot;);</span><br></pre></td></tr></table></figure></p><h2 id="元素样式型api"><a href="#元素样式型api" class="headerlink" title="元素样式型api"></a>元素样式型api</h2><h3 id="window-getComputedStyle"><a href="#window-getComputedStyle" class="headerlink" title="window.getComputedStyle"></a>window.getComputedStyle</h3><p>用来获取应用到元素后的样式，假设某个元素并未设置高度而是通过其内容将其高度撑开，这时候要获取它的高度就要用到getComputedStyle<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var style = window.getComputedStyle(element[, pseudoElt]);</span><br></pre></td></tr></table></figure></p><h3 id="getBoundingClientRect"><a href="#getBoundingClientRect" class="headerlink" title="getBoundingClientRect"></a>getBoundingClientRect</h3><p>返回元素的大小以及相对于浏览器可视窗口的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var clientRect = element.getBoundingClientRect();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>原型与原型链</title>
      <link href="/2019/07/06/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2019/07/06/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="全局对象-window"><a href="#全局对象-window" class="headerlink" title="全局对象 window"></a>全局对象 window</h2><p><strong>window 的属性就是全局变量。</strong><br><strong>window属性：</strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document" target="_blank" rel="noopener">window</a></p><h2 id="全局函数"><a href="#全局函数" class="headerlink" title="全局函数"></a>全局函数</h2><ol><li>Number<br><code>var n = new Number()</code>创建一个 Number 对象</li><li>String<br><code>var s = new String(&#39;hello&#39;)</code> 创建一个 String 对象</li><li>Boolean<br><code>var b = new Boolean(true)</code> 创建一个 Boolean 对象</li><li>Object<br><code>var o1 = {}</code> 创建一个 Object 对象<br><code>(var o2 = new Object()</code> 创建一个 Object 对象</li></ol><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p><strong>重要公式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var 对象 = new 函数()</span><br><span class="line"></span><br><span class="line">对象.__proto__ === 对象的构造函数.prototype</span><br><span class="line"></span><br><span class="line">// 推论</span><br><span class="line"></span><br><span class="line">var number = new Number()</span><br><span class="line"></span><br><span class="line">number.__proto__ = Number.prototype</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var object = new Object()</span><br><span class="line"></span><br><span class="line">object.__proto__ = Object.prototype</span><br><span class="line"></span><br><span class="line">var function = new Function()</span><br><span class="line"></span><br><span class="line">function.__proto__ = Function.prototype</span><br><span class="line"></span><br><span class="line">// 另外，所有函数都是由 Function 构造出来的，所以</span><br><span class="line"></span><br><span class="line">Number.__proto__ = Function.prototype // 因为 Number 是函数，是 Function 的实例</span><br><span class="line"></span><br><span class="line">Object.__proto__ = Function.prototype // 因为 Object 是函数，是 Function 的实例</span><br><span class="line"></span><br><span class="line">Function.__proto__ == Function.prototye // 因为 Function 是函数，是 Function 的实例！</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>JS里的数据类型转换</title>
      <link href="/2019/07/05/JS%E9%87%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2019/07/05/JS%E9%87%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="任意类型转字符串"><a href="#任意类型转字符串" class="headerlink" title="任意类型转字符串"></a>任意类型转字符串</h2><h3 id="String-x"><a href="#String-x" class="headerlink" title="String(x)"></a>String(x)</h3><p><img src="https://static.xiedaimala.com/FrpnWPAjH4_Zh1Ru58nEIC0I4onn" alt="图片"></p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p><img src="https://static.xiedaimala.com/FnbB3yikB790jzpavhE6eyqioUPP" alt="图片"></p><h3 id="0"><a href="#0" class="headerlink" title="+ 0"></a>+ 0</h3><p><img src="https://static.xiedaimala.com/FgaPxjEAu8-hzeBRnQ7jdHlZiw85" alt="图片"></p><h2 id="任意类型转为number"><a href="#任意类型转为number" class="headerlink" title="任意类型转为number"></a>任意类型转为number</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&apos;1&apos; -&gt; 1</span><br><span class="line">Number(&apos;1&apos;) === 1</span><br><span class="line">parseInt(&apos;1&apos;, 10) === 1</span><br><span class="line">parseFloat(&apos;1.23&apos;) === 1.23</span><br><span class="line">&apos;1&apos; + 0 === 1</span><br></pre></td></tr></table></figure><h2 id="任意类型转boolean"><a href="#任意类型转boolean" class="headerlink" title="任意类型转boolean"></a>任意类型转boolean</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Boolean(x)</span><br><span class="line">!!x</span><br></pre></td></tr></table></figure><h2 id="数据类型的false值"><a href="#数据类型的false值" class="headerlink" title="数据类型的false值"></a>数据类型的false值</h2><p> <code>0</code>、<code>NaN</code>、<code>false</code>、<code></code>、<code>undefined</code>、<code>null</code></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>JS里的数据类型</title>
      <link href="/2019/07/05/JS%E9%87%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/07/05/JS%E9%87%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript的七种数据类型"><a href="#JavaScript的七种数据类型" class="headerlink" title="JavaScript的七种数据类型"></a>JavaScript的七种数据类型</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>数值<code>number</code>、字符串<code>string</code>、布尔值<code>Boolean</code>、<code>symbol</code>、<code>undefined</code>、<code>null</code></p><h3 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a>复杂类型</h3><p>对象<code>object</code>— 狭义的对象<code>object</code>、数组<code>array</code>、函数<code>function</code></p><h2 id="null-和-undefined的区别"><a href="#null-和-undefined的区别" class="headerlink" title="null 和 undefined的区别"></a>null 和 undefined的区别</h2><ul><li>当变量没有赋值时— undefined</li><li>有对象<code>object</code>,但还没赋值 — null</li><li>有非对象<code>object</code>,不想赋值 — undefined</li></ul><h3 id="JavaScript三种方法确定数据类型"><a href="#JavaScript三种方法确定数据类型" class="headerlink" title="JavaScript三种方法确定数据类型"></a>JavaScript三种方法确定数据类型</h3><ol><li><p>typeof运算符</p></li><li><p>instanceof运算符</p></li><li><p>Object.prototype.toString方法</p></li></ol><h2 id="JavaScript内容详细内容"><a href="#JavaScript内容详细内容" class="headerlink" title="JavaScript内容详细内容"></a>JavaScript内容详细内容</h2><p>1、<a href="https://wangdoc.com/javascript/" target="_blank" rel="noopener">阮一峰JavaScript教程</a><br>2、<a href="http://javascript.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>CSS布局</title>
      <link href="/2018/12/11/CSS%E5%B8%83%E5%B1%80/"/>
      <url>/2018/12/11/CSS%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="本文主要包括以下内容："><a href="#本文主要包括以下内容：" class="headerlink" title="本文主要包括以下内容："></a>本文主要包括以下内容：</h2><ol><li>左右布局</li><li>左中右布局</li><li>水平居中</li><li>垂直居中</li><li>等其他小技巧</li></ol><h3 id="1、左右布局（两栏布局）"><a href="#1、左右布局（两栏布局）" class="headerlink" title="1、左右布局（两栏布局）"></a>1、左右布局（两栏布局）</h3><ul><li>两栏布局： <strong>一栏定宽，一栏自适应</strong>。</li><li>链接:<br><a href="http://js.jirengu.com/ruzogewubi/1/edit?html,css,output" target="_blank" rel="noopener">两栏布局</a></li></ul><h3 id="2、左中右布局-三栏布局"><a href="#2、左中右布局-三栏布局" class="headerlink" title="2、左中右布局(三栏布局)"></a>2、左中右布局(三栏布局)</h3><ul><li>三栏布局：<strong>两边定宽，然后中间的width是auto自适应内容</strong>。</li><li>链接:<br><a href="http://js.jirengu.com/dezilezuke/1/edit?html,css,output" target="_blank" rel="noopener">三栏布局</a></li></ul><h3 id="3、水平居中"><a href="#3、水平居中" class="headerlink" title="3、水平居中"></a>3、水平居中</h3><ul><li>flex实现水平居中: <strong>Flexbox布局自适应调整和分布一个容器里的项目布局，即使他们的大小是未知或者是动态的</strong>。</li><li>链接:<br><a href="http://js.jirengu.com/wisegaguco/1/edit?html,css,output" target="_blank" rel="noopener">flex水平居中</a></li></ul><h3 id="4、垂直居中"><a href="#4、垂直居中" class="headerlink" title="4、垂直居中"></a>4、垂直居中</h3><ul><li>绝对定位与负边距实现: <strong>利用绝对定位，将元素的top和left属性都设为50%，再利用margin边距，将元素回拉它本身高宽的一半，实现垂直居中。</strong></li><li>链接:<br><a href="http://js.jirengu.com/nolikenemi/1/edit?html,css,output" target="_blank" rel="noopener">绝对定位与负边距实现</a></li><li>绝对定位与margin: <strong>利用绝对定位与margin，但是无需知道被垂直居中元素的高和宽</strong>。</li><li>链接:<br><a href="http://js.jirengu.com/huzetituqu/1/edit" target="_blank" rel="noopener">绝对定位与margin</a></li></ul><h3 id="5、等其他小技巧"><a href="#5、等其他小技巧" class="headerlink" title="5、等其他小技巧"></a>5、等其他小技巧</h3><ul><li>水平垂直居中(flex布局)</li><li>链接<br><a href="http://js.jirengu.com/limoyefato/1/edit?html,css,output" target="_blank" rel="noopener">水平垂直居中flex布局</a></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>CSS</title>
      <link href="/2018/12/10/CSS/"/>
      <url>/2018/12/10/CSS/</url>
      
        <content type="html"><![CDATA[<h2 id="本文主要包括以下内容："><a href="#本文主要包括以下内容：" class="headerlink" title="本文主要包括以下内容："></a>本文主要包括以下内容：</h2><ol><li>高度是由什么决定的?</li><li>line-box 是啥?</li><li>box 是啥（盒模型）?</li><li>宽度是由什么决定的?</li><li>position 的 5 个取值</li><li>z-index</li></ol><h3 id="1、高度是由什么决定的"><a href="#1、高度是由什么决定的" class="headerlink" title="1、高度是由什么决定的?"></a>1、高度是由什么决定的?</h3><ul><li><strong>内联元素</strong> (自左往右,自动换行，但如果内联元素是一个很长的英文单词，则不会分开换行)<br><code>内联元素的高是由字体设计师决定</code> </li><li><strong>块级元素</strong> (从上往下，占据整行)<br><code>块级元素的高度由其内部文档流元素的高度总分决定的</code></li></ul><h3 id="2、line-box-是啥"><a href="#2、line-box-是啥" class="headerlink" title="2、line-box 是啥?"></a>2、line-box 是啥?</h3><ul><li>每一行称为一条Line Box，它又是由这一行的许多<strong>inline-box组成，它的高度可以直接由line-height决定</strong>，line boxes的高度垂直堆叠形成了containing box的高度，就是我们见到的div或是p标签之类的高度了。</li></ul><h3 id="3、box-是啥（盒模型）"><a href="#3、box-是啥（盒模型）" class="headerlink" title="3、box 是啥（盒模型）?"></a>3、box 是啥（盒模型）?</h3><ul><li>盒模型对比<br><img src="http://upload-images.jianshu.io/upload_images/6970717-2046f9172e7c0e58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="盒模型对比.png"><br><code>W3C标准中padding、border所占的空间不在width、height范围内，大家俗称的IE的盒模型width包括content尺寸＋padding＋border</code></li></ul><h3 id="4、宽度是由什么决定的"><a href="#4、宽度是由什么决定的" class="headerlink" title="4、宽度是由什么决定的?"></a>4、宽度是由什么决定的?</h3><ul><li><strong>行内元素</strong>的宽度是由它的<strong>内容</strong>决定的，行内元素不能设置宽高</li><li><strong>块级元素</strong>当没有设置宽度是<strong>默认100%宽</strong>，当设置了宽度是就是固定的宽度 </li></ul><h3 id="5、position-的-5-个取值"><a href="#5、position-的-5-个取值" class="headerlink" title="5、position 的 5 个取值"></a>5、position 的 5 个取值</h3><ul><li>sticky</li><li>absolute</li><li>fixed</li><li>relative</li><li>static</li></ul><h3 id="6、z-index"><a href="#6、z-index" class="headerlink" title="6、z-index"></a>6、z-index</h3><ul><li><strong>z-index 属性指定了一个具有定位属性的元素及其子代元素的 z-order。 当元素之间重叠的时候，z-order 决定哪一个元素覆盖在其余元素的上方显示。 通常来说 z-index 较大的元素会覆盖较小的一个。</strong></li><li>链接：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index" target="_blank" rel="noopener">z-index标签</a></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>HTML_Common</title>
      <link href="/2018/12/09/HTML-Common/"/>
      <url>/2018/12/09/HTML-Common/</url>
      
        <content type="html"><![CDATA[<h2 id="本文主要包括以下内容："><a href="#本文主要包括以下内容：" class="headerlink" title="本文主要包括以下内容："></a>本文主要包括以下内容：</h2><ol><li>iframe 标签</li><li>a 标签</li><li>form 标签</li><li>input / button标签</li><li>table 标签</li></ol><h3 id="1、iframe-标签"><a href="#1、iframe-标签" class="headerlink" title="1、iframe 标签"></a>1、iframe 标签</h3><ul><li>嵌套页面<br><code>&lt;iframe src=&quot;https://www.baidu.com&quot; name=&quot;xxx&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;</code></li><li>常用和<code>&lt;a&gt;</code>使用<br><code>&lt;a href=&quot;https://qq.com&quot; target=xxx&gt;</code></li></ul><h3 id="2、a-标签"><a href="#2、a-标签" class="headerlink" title="2、a 标签"></a>2、a 标签</h3><ul><li>跳转页面（<strong>HTTP GET 请求</strong>）</li><li>属性：</li><li>链接：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a" target="_blank" rel="noopener">a标签</a></li></ul><h3 id="3、form-标签"><a href="#3、form-标签" class="headerlink" title="3、form 标签"></a>3、form 标签</h3><ul><li>跳转页面（<strong>HTTP POST 请求</strong>）</li><li>属性：</li><li>链接：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/form" target="_blank" rel="noopener">form标签</a></li></ul><h3 id="4、input-button标签"><a href="#4、input-button标签" class="headerlink" title="4、input / button标签"></a>4、input / button标签</h3><ul><li><strong>区别</strong>：是否为「空标签」</li><li>input 的属性如：</li><li>链接：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input" target="_blank" rel="noopener">input标签</a></li></ul><blockquote><p><code>&lt;input type=&quot;text&quot;&gt;</code><br><code>&lt;input type=&quot;password&quot;&gt;</code><br><code>&lt;input type=&quot;submit&quot;&gt;</code><br><code>&lt;input type=&quot;checkbox&quot; value=&quot;xxx&quot;&gt;</code><br><code>&lt;input type=&quot;radio&quot; value=&quot;yyy&quot;&gt;</code></p></blockquote><ul><li>button 的属性如：</li><li>链接：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button" target="_blank" rel="noopener">button</a></li></ul><blockquote><p><code>&lt;button name=&quot;button&quot;&gt;Click me&lt;/button&gt;</code><br><code>&lt;button&gt;Click me&lt;/button&gt;</code></p></blockquote><h3 id="5、table-标签"><a href="#5、table-标签" class="headerlink" title="5、table 标签"></a>5、table 标签</h3><ul><li><strong>用于展示数据</strong></li><li>table 的属性：</li><li>链接：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/table" target="_blank" rel="noopener">table标签</a></li><li>table 实现标签:<br><code>tr --- table row</code>, <code>th --- table header cell</code>, <code>td --- table data cell</code></li><li><strong>知识点</strong>：<ul><li>空标签</li><li>可替换标签</li><li>全局属性</li><li>display 不止 3 种</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>HTML</title>
      <link href="/2018/12/08/HTML/"/>
      <url>/2018/12/08/HTML/</url>
      
        <content type="html"><![CDATA[<h2 id="本文主要包括以下内容："><a href="#本文主要包括以下内容：" class="headerlink" title="本文主要包括以下内容："></a>本文主要包括以下内容：</h2><ol><li>HTML 的版本</li><li>怎样理解 HTML 语义化</li><li>怎样理解内容与样式分离的原则</li><li>有哪些常见的meta标签</li><li>文档声明的作用?严格模式和混杂模式指什么?&lt;!doctype html&gt; 的作用?</li><li>浏览器乱码的原因是什么？如何解决?</li><li>常见的浏览器有哪些？什么内核？</li><li>列出常见的标签，并简单介绍这些标签用在什么场景</li></ol><h3 id="1、HTML-的版本"><a href="#1、HTML-的版本" class="headerlink" title="1、HTML 的版本"></a>1、HTML 的版本</h3><ul><li>HTML <code>超文本标记语言</code>（HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。</li><li>XML <code>可扩展标识语言</code>(The Extensible Markup Language)的简写，主要用于存储数据和结构。</li><li>XHTML <code>可扩展标识语言</code> (The Extensible HyperText Markup Language)的缩写,基于XML，作用与HTML类似,目的就是实现HTML向XML的过渡。 </li></ul><h3 id="2、怎样理解-HTML-语义化"><a href="#2、怎样理解-HTML-语义化" class="headerlink" title="2、怎样理解 HTML 语义化"></a>2、怎样理解 HTML 语义化</h3><ul><li>语义化HTML是一种编写HTML的方式。</li><li>选择合适的标签、使用合理的代码结构，便于开发者阅读，同时让浏览器的爬虫和机器很好地解析。</li><li>语义化的好处:<ol><li>页面呈现出很好地<strong>内容结构、代码结构</strong>。</li><li><strong>用户体验好</strong>。</li><li>利于<strong>SEO优化</strong>。</li><li>方便其他设备<strong>解析</strong>来渲染网页。</li><li>便于<strong>团队开发和维护</strong>，语义化更具<strong>可读性</strong>。</li></ol></li></ul><h3 id="3、怎样理解内容与样式分离的原则"><a href="#3、怎样理解内容与样式分离的原则" class="headerlink" title="3、怎样理解内容与样式分离的原则"></a>3、怎样理解内容与样式分离的原则</h3><ul><li>在WEB开发中， 一个网页分为三部分：<code>Html——结构（内容）</code>，<code>css——表现（样式）</code>，<code>javascrip——行为</code>。内容与样式分离，就是让内容的归 HTML, 样式归 CSS。同时，HTML 内不允许出现属性样式，尽量不要出现行内样式。</li><li>编码正确做法是HTML和CSS要分开使用，不要混着用。重点放在HTML的结构和语义化上，让HTML能提现页面结构或者内容,，然后进行 css 样式设置（即内容与样式分离） ，写JS的时候，尽量不要用JS去直接操作样式，而是通过给元素添加删除class来控制样式变化（即行为分离）。</li><li>分离原则的优点:<ol><li><strong>浏览器加载网页页面速度变快</strong>。分离原则下，大部分页面代码写在了CSS当中，页面体积容量变得更小。</li><li><strong>网页修改设计时，效率、省时</strong>。根据html标签内ID或class的标记，到CSS里找到相应的ID或class，可以快速替换指定位置的样式，不会破坏页面架构和其他部分的样式。</li><li><strong>典型的应用就是网页换肤</strong>。使用相同的 html 结构，不同的 CSS 样式。</li><li><strong>更好地被搜索引擎收录</strong>。基于内容与样式分离的原则，html的语义化就是首要考虑的,网页中语义化的标签代码就会更加适合搜索引擎。</li><li><strong>CSS样式的分离，它可以根据不同的浏览器，达到显示效果的统一</strong>。保证网页架构不变形的前提下，放心在不同浏览器渲染显示样式。</li></ol></li></ul><h3 id="4、有哪些常见的meta标签"><a href="#4、有哪些常见的meta标签" class="headerlink" title="4、有哪些常见的meta标签"></a>4、有哪些常见的meta标签</h3><ul><li><p>语言采用<strong>中文</strong><br><code>&lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;zh-CN&quot; /&gt;</code>       </p></li><li><p>编码格式：<strong>告诉给浏览器用什么方式来都这页代码</strong><br>  <code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>       </p></li><li>如果支持Google Chrome Frame：GCF，则使用GCF渲染；如果系统安装ie8或以上版本，则使用最高版本ie渲染； 否则，这个设定可以忽略。 目的<strong>使内容在移动端上比较合理展示</strong>。<br>  <code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;</code>    </li><li>控制网页为全屏幕大小<br>  <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;</code></li><li>目的是方便<strong>SEO优化</strong>内容关键字搜索<br>  <code>&lt;meta name=&quot;keywords&quot; content=&quot;&quot;&gt;</code></li></ul><h3 id="5、文档声明的作用-严格模式和混杂模式指什么-lt-doctype-html-gt-的作用"><a href="#5、文档声明的作用-严格模式和混杂模式指什么-lt-doctype-html-gt-的作用" class="headerlink" title="5、文档声明的作用?严格模式和混杂模式指什么?&lt;!doctype html&gt; 的作用?"></a>5、文档声明的作用?严格模式和混杂模式指什么?&lt;!doctype html&gt; 的作用?</h3><ul><li>文档声明的作用  <p>文档声明目的是<strong>防止出现乱码</strong>情况。</p></li><li>严格模式和混杂模式指什么<br><strong>严格模式</strong>：又称标准模式，是指<strong>浏览器按照 W3C 标准解析代码</strong>。<br><strong>混杂模式</strong>：又称怪异模式或兼容模式，是指<strong>浏览器用自己的方式解析代码</strong>。<br>   <strong>区分</strong>    ：浏览器解析时到底使用严格模式还是混杂模式，与网页中的 <strong>DTD</strong> 直接相关。</li><li>关于&lt;!DOCTYPE html&gt;<ul><li>关于<doctype>声明叫做文件类型定义（DTD），声明的作用<strong>为了告诉浏览器该文件的类型。让浏览器解析器知道应该用哪个规范来解析文档</strong>。</doctype></li></ul></li></ul><h3 id="6、浏览器乱码的原因是什么？如何解决"><a href="#6、浏览器乱码的原因是什么？如何解决" class="headerlink" title="6、浏览器乱码的原因是什么？如何解决?"></a>6、浏览器乱码的原因是什么？如何解决?</h3><ul><li>html源代码内中文字内容与html编码不同造成。但无论是哪种情况造成乱码在网页开始时候都需要设置网页编码。</li><li>解决：<br>  <code>&lt;meta charset=&quot;utf-8&quot;&gt;</code></li></ul><h3 id="7、常见的浏览器有哪些？什么内核？"><a href="#7、常见的浏览器有哪些？什么内核？" class="headerlink" title="7、常见的浏览器有哪些？什么内核？"></a>7、常见的浏览器有哪些？什么内核？</h3><ul><li><p>浏览器</p><p>chrome浏览器、火狐浏览器（Mozilla Firefox）、IE浏览器、360极速浏览器、搜狗浏览器、猎豹极轻浏览器等。</p></li><li><p>内核<br>1、Trident(IE内核)；<br>2、Gecko(Firefox内核)；<br>3、Presto(Opera前内核) (已废弃)；<br>4、Webkit(Safari内核,Chrome内核原型,开源)。</p></li></ul><h3 id="8、列出常见的标签，并简单介绍这些标签用在什么场景"><a href="#8、列出常见的标签，并简单介绍这些标签用在什么场景" class="headerlink" title="8、列出常见的标签，并简单介绍这些标签用在什么场景"></a>8、列出常见的标签，并简单介绍这些标签用在什么场景</h3><ul><li><p><strong>注意点</strong><br>1、标签属性全小写;<br>2、标签要闭合、自闭合标签可以省略 /;<br>3、标题里不能有段落，段落里不能有标题;</p></li><li><p><code>h1~h6</code> 标题<br> </p><h1>代表页面最大的标题</h1><br> <h2>二级标题</h2><br> <h3>更弱的标题</h3><br> <h4>…</h4><br> <h5>…</h5><p></p> <h6>最小标题</h6></li><li><p><code>p</code>段落</p> <p>表示大段文字</p></li><li><p><code>a</code>链接，链到一个地址<br> &lt;a href=”<a href="http://www.google.com&quot;&quot;" target="_blank" rel="noopener">http://www.google.com&quot;&quot;</a> target=”_blank” title=”ABC”&gt;google.com<br> <a href="#">空</a><br> <a href="#about">定位ID标签about位置</a><br> <a href="/getCourse">链接路径地址</a></p></li><li><p><code>img</code>展示一张图片<br>   <img src="a.png" alt=""></p></li><li><p><code>div</code>语义为“一大块”，用于给页面划分区块，让结构更清晰</p>   <div id="header">…</div><br>   <div id="content">…</div><br>   <div id="footer">…</div></li><li><p><code>ul li</code></p><ol><li>ul: unsort list 无序列表</li><li>用于表示并列的内容</li><li>ul的直接子元素是li</li><li>可以嵌套<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=&quot;nav&quot;&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;关于&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;a href=&quot;#&quot;&gt;更多&lt;/a&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;联系&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;地址&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;·</span><br></pre></td></tr></table></figure></li></ol></li><li><p><code>ol li</code></p><ol><li>ol: order list 有序序列表 </li><li>用于表示带步骤或者编号的并列内容 </li><li>ol的直接子元素只能是li 可以嵌套</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;把大象关到冰箱的步骤&lt;/h2&gt;</span><br><span class="line">&lt;ol&gt;</span><br><span class="line">  &lt;li&gt;把大象变小&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;打开冰箱&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;把大象塞进去&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure><ul><li>dl dt dd用于展示一系列 “标题:内容… ”的场景</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dl&gt;</span><br><span class="line">    &lt;dt&gt;商品名称:&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;青花瓷&lt;/dd&gt;</span><br><span class="line">    &lt;dt&gt;特征:&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;白色&lt;/dd&gt;</span><br><span class="line">    &lt;dd&gt;圆口&lt;/dd&gt;</span><br><span class="line">    &lt;dt&gt;商品介绍&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;这是一个年代久远的瓷器，很贵，易碎&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure><ul><li><p><code>button</code>按钮</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button&gt;点我&lt;/button&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>strong em</code></p><ol><li>em 需要强调一下</li><li>strong 很重要、强调性更强<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;p&gt;优惠 &lt;strong&gt;100&lt;/strong&gt; 元&lt;/p&gt;</span><br><span class="line">&lt;p&gt;小谷 &lt;em&gt;2&lt;/em&gt; 岁了&lt;/p&gt;</span><br></pre></td></tr></table></figure></li></ol></li><li><p><code>iframe</code>用于嵌入一个页面 注意跨域操作问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;iframe src=&quot;http://www.google.com&quot; name=&quot;myPage&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;p&gt;&lt;a href=&quot;http://www.baidu.com&quot;&quot; target=&quot;myPage&quot;&gt;baidu.com&lt;/a&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>table</code>用于展示表格，不要用来做布局 thead tbody tfoot可省略，浏览器会自动添加 border-collapse: collapse;用于合并边框</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;th&gt;姓名&lt;/th&gt;</span><br><span class="line">  &lt;th&gt;年纪&lt;/th&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;td&gt;小明&lt;/td&gt;</span><br><span class="line">  &lt;td&gt;18&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;td&gt;小花&lt;/td&gt;</span><br><span class="line">  &lt;td&gt;20&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>HTTP</title>
      <link href="/2018/12/07/HTTP/"/>
      <url>/2018/12/07/HTTP/</url>
      
        <content type="html"><![CDATA[<h2 id="本文主要包括以下内容："><a href="#本文主要包括以下内容：" class="headerlink" title="本文主要包括以下内容："></a>本文主要包括以下内容：</h2><ol><li><p>HTTP是什么？</p></li><li><p>HTTP 请求包括哪些部分？</p></li><li><p>HTTP 响应包括哪些部分？</p></li><li><p>如何用Chrome开发者工具查看 HTTP 请求及请求的内容？</p></li><li><p>如何使用 curl 命令？</p></li></ol><h3 id="1、HTTP是什么"><a href="#1、HTTP是什么" class="headerlink" title="1、HTTP是什么?"></a>1、HTTP是什么?</h3><ul><li><p><code>HTTP</code> 全称：HyperText Transfer Protocol，即超文本传输协议<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">HTTP</a>的作用。</p></li><li><p><code>HTTP作用</code> : 指导浏览器和服务器之间进行沟通。</p></li></ul><h3 id="2、HTTP-请求包括哪些部分？"><a href="#2、HTTP-请求包括哪些部分？" class="headerlink" title="2、HTTP 请求包括哪些部分？"></a>2、HTTP 请求包括哪些部分？</h3><ul><li>HTTP请求主要包括四部分（第四部分可以为空），主要格式如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1 动词 路径 协议/版本</span><br><span class="line"></span><br><span class="line">2 Key1: value1</span><br><span class="line"></span><br><span class="line">2 Key2: value2</span><br><span class="line"></span><br><span class="line">2 Key3: value3</span><br><span class="line"></span><br><span class="line">2 Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">2 Host: www.baidu.com</span><br><span class="line"></span><br><span class="line">2 User-Agent: curl/7.54.0</span><br><span class="line"></span><br><span class="line">3 </span><br><span class="line"></span><br><span class="line">4 要上传的数据</span><br></pre></td></tr></table></figure></li></ul><h3 id="3、HTTP-响应包括哪些部分？"><a href="#3、HTTP-响应包括哪些部分？" class="headerlink" title="3、HTTP 响应包括哪些部分？"></a>3、HTTP 响应包括哪些部分？</h3><ul><li>HTTP响应主要包括四部分（第四部分可以为空），主要格式如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1 协议/版本号 状态码 状态解释</span><br><span class="line">2 Key1: value1</span><br><span class="line">2 Key2: value2</span><br><span class="line">2 Content-Length: 17931</span><br><span class="line">2 Content-Type: text/html</span><br><span class="line">3</span><br><span class="line">4 要下载的内容</span><br></pre></td></tr></table></figure></li></ul><h3 id="4、如何用Chrome开发者工具查看-HTTP-请求及响应的内容？"><a href="#4、如何用Chrome开发者工具查看-HTTP-请求及响应的内容？" class="headerlink" title="4、如何用Chrome开发者工具查看 HTTP 请求及响应的内容？"></a>4、如何用Chrome开发者工具查看 HTTP 请求及响应的内容？</h3><ul><li>eg：用<strong>Chrome</strong>发请求</li></ul><ol><li>打开 Network</li><li>地址栏输入网址</li><li>在 Network 点击，查看 request，点击「view source」</li><li>点击「view source」可查看请求的前三部分</li><li>如果有请求的第四部分，那么在 FormData 或 Payload 里面可以看到</li></ol><ul><li>用<strong>Chrome</strong>查看响应</li></ul><ol><li>打开 Network</li><li>输入网址</li><li>选中第一个响应</li><li>查看 Response Headers，点击「view source」</li><li>查看响应的前两部分</li><li>查看 Response 或者 Preview，你会看到响应的第 4 部分</li></ol><h3 id="5、如何使用-curl-命令？"><a href="#5、如何使用-curl-命令？" class="headerlink" title="5、如何使用 curl 命令？"></a>5、如何使用 curl 命令？</h3><ul><li><code>Curl</code>是Linux下一个很强大的http命令行工具。</li><li>curl的基本用途：创造一个请求，并得到响应，主要如下图：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -s -v -H &quot;Nola: xxx&quot; -- &quot;https://www.baidu.com&quot;</span><br><span class="line">请求内容：</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">User-Agent: curl/7.54.0</span><br><span class="line">Accept: */*</span><br><span class="line">Nola: xxx</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -s -v -H &quot;Nola: xxx&quot; -- &quot;https://www.baidu.com&quot;</span><br><span class="line">请求内容：</span><br><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">User-Agent: curl/7.54.0</span><br><span class="line">Accept: */*</span><br><span class="line">Nola: xxx</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -d &quot;1234567890&quot; -s -v -H &quot;Nola: xxx&quot; -- &quot;https://www.baidu.com&quot;</span><br><span class="line">请求内容：</span><br><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">User-Agent: curl/7.54.0</span><br><span class="line">Accept: */*</span><br><span class="line">Nola: xxx</span><br><span class="line">Content-Length: 10</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>开博大吉</title>
      <link href="/2018/12/07/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/"/>
      <url>/2018/12/07/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</url>
      
        <content type="html"><![CDATA[<h3 id="学习记录前端小知识"><a href="#学习记录前端小知识" class="headerlink" title="学习记录前端小知识"></a>学习记录前端小知识</h3>]]></content>
      
      
      
    </entry>
    
  
  
</search>
