<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Vue-note</title>
      <link href="/2019/11/19/Vue-note/"/>
      <url>/2019/11/19/Vue-note/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue学习笔记"><a href="#Vue学习笔记" class="headerlink" title="Vue学习笔记"></a>Vue学习笔记</h2><h3 id="Vue-js-是什么"><a href="#Vue-js-是什么" class="headerlink" title="Vue.js 是什么"></a>Vue.js 是什么</h3><p>Vue是一套用于构造用户界面的<strong>渐进式框架</strong>，遵循<code>MVVM</code>模型。<br>Model(模型)：数据保存 View(视图): 用户界面。<br>采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel上，反之亦然。<br><img src="https://i.niupic.com/images/2019/11/19/_1151.png" alt="MVVM"></p><h3 id="Vue特性"><a href="#Vue特性" class="headerlink" title="Vue特性"></a>Vue特性</h3><h4 id="v-bind绑定"><a href="#v-bind绑定" class="headerlink" title="v-bind绑定"></a>v-bind绑定</h4><p><code>v-bind:title=&quot;message&quot;</code><br>  将这个元素节点的 title 特性和 Vue 实例的 message 属性保持一致。</p><h4 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h4><p><code>&lt;li v-for=&quot;todo of todos&quot;&gt;&lt;/li&gt;</code><br>  绑定数组的数据来渲染一个项目列表</p><h4 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h4><p><code>&lt;button v-on:click=&quot;reverseMessage&quot;&gt;反转消息&lt;/button&gt;</code><br>  添加一个事件监听器，通过它调用在 Vue 实例中定义的方法</p><h4 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h4><p><code>&lt;input v-model=&quot;message&quot;&gt;</code><br>  实现表单输入和应用状态之间的双向绑定</p><h3 id="组件化应用构建"><a href="#组件化应用构建" class="headerlink" title="组件化应用构建"></a>组件化应用构建</h3><p>  在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。分为<strong>全局组件和局部组件</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 定义名todo-item的全局组件</span><br><span class="line">// JS</span><br><span class="line">Vue.component(&apos;todo-item&apos;, &#123;</span><br><span class="line">  props: [&apos;content&apos;], // 接收父组件向子组件传递数据</span><br><span class="line">  template: &apos;&lt;li @delete=&quot;handleItemClick&quot;&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;&apos;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleItemClick() &#123;</span><br><span class="line">      this.$emit(&apos;delete&apos;, index) // 通过$emit实例属性触发事件。将子组件数据和索引传递给父组件</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 构建另一个组件模板</span><br><span class="line">// HTML</span><br><span class="line">&lt;ol&gt;</span><br><span class="line">  &lt;!-- 创建一个 todo-item 组件的实例 --&gt;</span><br><span class="line">  &lt;todo-item v-bind:content=&quot;item&quot; </span><br><span class="line">              v-bind:index=&quot;index&quot; </span><br><span class="line">              &quot;v-for=&quot;(item,index) in list&quot;&gt;</span><br><span class="line">  &lt;/todo-item&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure><p>  从父作用域将数据传到子组件: <strong>props接口</strong><br>  从子作用域将数据传到父组件: <strong>$emit实例属性</strong></p><h3 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h3><h4 id="创建一个Vue实例"><a href="#创建一个Vue实例" class="headerlink" title="创建一个Vue实例"></a>创建一个Vue实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  // 选项</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>  vm(ViewModel)这个变量名便是Vue实例</p><h4 id="数据与方法"><a href="#数据与方法" class="headerlink" title="数据与方法"></a>数据与方法</h4><p>  实例中<code>data</code>中的属性是响应式，使用<code>Object.freeze()</code>，这会阻止修改现有的属性，也意味着响应系统无法再追踪变化。<br>  <code>$</code>表示Vue实例</p><h4 id="实例生命周期钩子"><a href="#实例生命周期钩子" class="headerlink" title="实例生命周期钩子"></a>实例生命周期钩子</h4><p>  生命周期函数就是Vue在某一个时间点会自动执行的函数<br>  <img src="https://i.niupic.com/images/2019/11/19/_1154.png" alt="生命周期钩子"></p><h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><h4 id="v-once绑定"><a href="#v-once绑定" class="headerlink" title="v-once绑定"></a>v-once绑定</h4><p><code>&lt;span v-once&gt;这个将不会改变: &lt;/span&gt;</code><br>  执行一次性地插值</p><h4 id="v-html、v-text"><a href="#v-html、v-text" class="headerlink" title="v-html、v-text"></a>v-html、v-text</h4><p>  一般情况下，解释是相同的普通文本，但遇到有标签时，则需要使用<code>v-html</code></p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p><code>&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;</code><br><code>href</code>是参数，告知 v-bind 指令将该元素的 href 特性与表达式 url 的值绑定。</p><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p><code>.</code>指明的特殊后缀，用于指出一个指令应该以特殊方式绑定</p><h3 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h3><ol><li>计算属性(computed),有缓存机制，有利于性能优化。计算属性是基于它们的响应式依赖进行缓存的。<ul><li>setter </li><li>getter(默认)</li></ul></li><li>侦听器(watch)，没有缓存机制，浪费性能。当需要在数据变化时执行异步或开销较大的操作时。</li></ol><h3 id="Class-与-Style-绑定"><a href="#Class-与-Style-绑定" class="headerlink" title="Class 与 Style 绑定"></a>Class 与 Style 绑定</h3><h4 id="绑定-HTML-Class"><a href="#绑定-HTML-Class" class="headerlink" title="绑定 HTML Class"></a>绑定 HTML Class</h4><ol><li>对象语法<br><code>&lt;div v-bind:class=&quot;{ active: isActive }&quot;&gt;&lt;/div&gt;</code> </li><li>数组语法<br><code>&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;</code></li></ol><h4 id="绑定-HTML-Style"><a href="#绑定-HTML-Style" class="headerlink" title="绑定 HTML Style"></a>绑定 HTML Style</h4><ol><li>对象语法<br><code>&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;</code></li><li>数组语法<br><code>&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;</code></li></ol><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><h4 id="v-if、v-else-if和v-else"><a href="#v-if、v-else-if和v-else" class="headerlink" title="v-if、v-else-if和v-else"></a>v-if、v-else-if和v-else</h4><p><code>&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;</code><br><code>&lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;</code><br>  指令的表达式<code>awesome</code>返回true时渲染，否则渲染else语句，<code>v-else-if</code>可以连续使用</p><h4 id="用-key-管理可复用的元素"><a href="#用-key-管理可复用的元素" class="headerlink" title="用 key 管理可复用的元素"></a>用 key 管理可复用的元素</h4><p>  目的是使Vue尽可能高效地渲染元素。</p><h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h4><p><code>&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;</code><br>  根据条件展示元素,不同其它，始终会被渲染并保留在 DOM 中。</p><h4 id="v-if-与-v-show-的区别"><a href="#v-if-与-v-show-的区别" class="headerlink" title="v-if 与 v-show 的区别"></a>v-if 与 v-show 的区别</h4><ol><li>当<code>v-if</code>为false时，不会渲染，为true时渲染，能确保在切换过程中销毁和重建。</li><li><code>v-show</code>总是被渲染。</li><li><code>v-if</code>有更高的切换开销。<code>v-show</code>则更高的初始渲染开销。频繁切换，使用<code>v-show</code>，条件少使用<code>v-if</code>。<h4 id="v-for-与-v-if-同时使用"><a href="#v-for-与-v-if-同时使用" class="headerlink" title="v-for 与 v-if 同时使用"></a>v-for 与 v-if 同时使用</h4><strong>注： 不推荐同时使用。v-for 具有比 v-if 更高的优先级</strong></li></ol><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><h4 id="用-v-for-把一个数组对应为一组元素"><a href="#用-v-for-把一个数组对应为一组元素" class="headerlink" title="用 v-for 把一个数组对应为一组元素"></a>用 v-for 把一个数组对应为一组元素</h4><p><code>v-for</code>基于一个数组来渲染一个列表.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;example-1&quot;&gt;</span><br><span class="line">  &lt;li v-for=&quot;(item,index) of items&quot; v-bind:key=&quot;item.id&quot;&gt;</span><br><span class="line">    &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p><code>items</code> 是<strong>源数据数组</strong>，而 <code>item</code> 则是<strong>被迭代的数组元素的别名</strong>,<code>index</code>当前项的索引。<br>在 <code>v-for</code> 块中，我们可以访问所有父作用域的属性</p><h4 id="在-v-for-里使用对象"><a href="#在-v-for-里使用对象" class="headerlink" title="在 v-for 里使用对象"></a>在 v-for 里使用对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;v-for-object&quot; class=&quot;demo&quot;&gt;</span><br><span class="line">  &lt;li v-for=&quot;(value,name，index) in object&quot;&gt;</span><br><span class="line">   &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p><code>value</code>是键值，<code>name</code>是键名，<code>index</code>是索引<br><strong>记住得使用 <code>v-for</code> 时提供 <code>key attribute</code>，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</strong></p><h4 id="变异方法"><a href="#变异方法" class="headerlink" title="变异方法"></a>变异方法</h4><ul><li>push()</li><li>pop()</li><li>shift()</li><li>unshift()</li><li>splice()</li><li>sort()</li><li>reverse()</li></ul><h4 id="非变异方法、替换数组"><a href="#非变异方法、替换数组" class="headerlink" title="非变异方法、替换数组"></a>非变异方法、替换数组</h4><ul><li>filter()</li><li>concat()</li><li>slice()<br>它们不会改变原始数组，而总是返回一个<strong>新数组</strong>。当使用非变异方法时，可以用新数组替换旧数组。<br>注意：在对象或数组中，不可以直接设置或利用索引来修改数据，因为不是响应式。为了在修改数据时页面同时变化，可：<br>对象: <ol><li>直接改变对象引用</li><li>通过Vue全局方法<code>Vue.set( )</code>或Vue实例<code>vm.$set()</code></li></ol></li></ul><p>数组: </p><ol><li>直接改变数组引用</li><li>通过数组变异方法<br>3，通过Vue全局方法<code>Vue.set( )</code>或Vue实例<code>vm.$set()</code></li></ol><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><h4 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h4><p><code>v-on</code>监听 DOM 事件</p><h4 id="事件处理方法"><a href="#事件处理方法" class="headerlink" title="事件处理方法"></a>事件处理方法</h4><p>v-on 还可以接收一个需要调用的方法名称</p><h4 id="内联处理器中的方法"><a href="#内联处理器中的方法" class="headerlink" title="内联处理器中的方法"></a>内联处理器中的方法</h4><p>在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 <code>$event</code> 把它传入方法.<br><code>$event</code>访问原始DOM事件</p><h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><ul><li>.stop  <code>&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</code> // 阻止单击事件继续传播</li><li>.prevent  <code>&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</code> // 提交事件不再重载页面</li><li>.capture <code>&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</code> // 添加事件监听器时使用事件捕获模式</li><li>.self <code>&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</code> //  只当在 event.target 是当前元素自身时触发处理函数</li><li>.once <code>&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;</code> // 点击事件将只会触发一次</li><li>.passive  <code>&lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;</code> // 不拦截默认preventDefault事件,阻止默认动作,能够提升移动端的性能。<br><strong>修饰符可以串联，并且顺序很重要；相应的代码会以同样的顺序产生。</strong></li></ul><h4 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h4><ul><li>.ctrl</li><li>.alt</li><li>.shift</li><li>.meta</li><li>.exact </li></ul><p><code>&lt;input @keyup.alt.67=&quot;clear&quot;&gt;</code> // Alt + C<br><code>&lt;div @click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt;</code> //  Ctrl + Click</p><h4 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h4><ul><li>.left</li><li>.right</li><li>.middle</li></ul><h4 id="为什么在HTML中使用v-on监听事件"><a href="#为什么在HTML中使用v-on监听事件" class="headerlink" title="为什么在HTML中使用v-on监听事件"></a>为什么在HTML中使用v-on监听事件</h4><p>主要Vue中遵循MVVM模式，将Vue.js事件处理方法和表达式都严格绑定在当前视图的ViewModel上,不会导致维护上的困难。<br>好处: </p><ol><li>代码清晰</li><li>无需手动绑定JavaScript事件，DOM完全解耦，易于测试。</li><li>ViewModel 被销毁时，所有的事件处理器都会自动被删除。</li></ol><h3 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h3><p><code>v-model</code>双向绑定，负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。<br>通过 JavaScript 在组件的 <code>data</code> 选项中声明初始值。</p><ul><li>.lazy  转变为使用 change 事件进行同步</li><li>.number  自动将用户的输入值转为数值类型</li><li>.trim 自动过滤用户输入的首尾空白字符</li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>算法排序</title>
      <link href="/2019/08/12/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/08/12/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>引用：(排序算法)[<a href="https://www.cnblogs.com/onepixel/p/7674659.html]" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/p/7674659.html]</a></p><h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><p>它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var arr = [2,4,23,52,15,73,26]</span><br><span class="line"></span><br><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">  var len = arr.length</span><br><span class="line">  for(let i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">    for(let j = 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">      if(arr[j] &gt; arr[j + 1]) &#123;  // 相邻元素两两对比</span><br><span class="line">        var temp = arr[j + 1]  // 元素交换</span><br><span class="line">        arr[j + 1] = arr[j]</span><br><span class="line">        arr[j] = temp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var arr = [2,4,23,52,15,73,26]</span><br><span class="line"></span><br><span class="line">function selectionSort(arr) &#123;</span><br><span class="line">  var len = arr.length</span><br><span class="line">  var minIndex, temp</span><br><span class="line">  for(let i = 0; i &lt; len -1; i++) &#123;</span><br><span class="line">    minIndex = i</span><br><span class="line">    for(let j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">      if(arr[j] &lt; arr[minIndex]) &#123; // 寻找最小的数</span><br><span class="line">        minIndex = j   // 将最小数的索引保存</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = arr[i]</span><br><span class="line">    arr[i] = arr[minIndex]</span><br><span class="line">    arr[minIndex] = temp</span><br><span class="line">  &#125;</span><br><span class="line">  return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序-（Insertion-Sort）"><a href="#插入排序-（Insertion-Sort）" class="headerlink" title="插入排序 （Insertion Sort）"></a>插入排序 （Insertion Sort）</h2><p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var arr = [2,4,23,52,15,73,26]</span><br><span class="line"></span><br><span class="line">function insertionSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    var preIndex, current;</span><br><span class="line">    for (var i = 1; i &lt; len; i++) &#123;</span><br><span class="line">        preIndex = i - 1;</span><br><span class="line">        current = arr[i];</span><br><span class="line">        while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex + 1] = arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + 1] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序-（Shell-Sort）"><a href="#希尔排序-（Shell-Sort）" class="headerlink" title="希尔排序 （Shell Sort）"></a>希尔排序 （Shell Sort）</h2><p>是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var arr = [2,4,23,52,15,73,26]</span><br><span class="line"></span><br><span class="line">function shellSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    for (var gap = Math.floor(len / 2); gap &gt; 0; gap = Math.floor(gap / 2)) &#123;</span><br><span class="line">        for (var i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            var j = i;</span><br><span class="line">            var current = arr[i];</span><br><span class="line">            while (j - gap &gt;= 0 &amp;&amp; current &lt; arr[j - gap]) &#123;</span><br><span class="line">                 arr[j] = arr[j - gap];</span><br><span class="line">                 j = j - gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序-（Merge-Sort）"><a href="#归并排序-（Merge-Sort）" class="headerlink" title="归并排序 （Merge Sort）"></a>归并排序 （Merge Sort）</h2><p>采用分治法，将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var arr = [2,4,23,52,15,73,26]</span><br><span class="line"></span><br><span class="line">function mergeSort(arr) &#123;</span><br><span class="line">  var len = arr.length</span><br><span class="line">  if(len &lt; 2 ) &#123;</span><br><span class="line">    return arr</span><br><span class="line">  &#125;</span><br><span class="line">  var middle = Math.floor(len / 2)</span><br><span class="line">  var left = arr.slice(0, middle)</span><br><span class="line">  var right = arr.slice(middle)</span><br><span class="line">  return merge(mergeSort(left), mergeSort(right))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function merge(left, right) &#123;</span><br><span class="line">  var result = []</span><br><span class="line"></span><br><span class="line">  while(left.length &gt; 0 &amp;&amp; right.length &gt; 0) &#123;</span><br><span class="line">    if(left[0] &lt;= right[0]) &#123;</span><br><span class="line">      result.push(left.shift())</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result.push(right.shift())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  while (left.length) &#123;</span><br><span class="line">    result.push(left.shift())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  while (right.length) &#123;</span><br><span class="line">    result.push(right.shift())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h2><p>通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var arr = [2,4,23,52,15,73,26]</span><br><span class="line"></span><br><span class="line"> var len = arr.length,</span><br><span class="line">        partitionIndex,</span><br><span class="line">        left = typeof left != &apos;number&apos; ? 0 : left,</span><br><span class="line">        right = typeof right != &apos;number&apos; ? len - 1 : right;</span><br><span class="line"> </span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">        partitionIndex = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, partitionIndex-1);</span><br><span class="line">        quickSort(arr, partitionIndex+1, right);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function partition(arr, left, right) &#123;</span><br><span class="line">  var pivot = left; // 设定基准值</span><br><span class="line">  var index = pivot + 1</span><br><span class="line">  for(var i = index; i &lt;= right; i++) &#123;</span><br><span class="line">    if(arr[i] &lt; arr[pivot]&gt;) &#123;</span><br><span class="line">      swap(arr, i , index)</span><br><span class="line">      index++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap(arr, pivot, index -1)</span><br><span class="line">  return index -1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function swap(arr, i ,j) &#123;</span><br><span class="line">  var temp = arr[i]</span><br><span class="line">  arr[i] = arr[j]</span><br><span class="line">  arr[j] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>ES6新特性</title>
      <link href="/2019/07/31/ES6%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2019/07/31/ES6%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>参考：<br><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰ES6</a>   <a href="https://fangyinghang.com/es-6-tutorials/" target="_blank" rel="noopener">ES6-MDN</a></p><h2 id="let-和-const命令"><a href="#let-和-const命令" class="headerlink" title="let 和 const命令"></a>let 和 const命令</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ol><li><code>let</code> 的作用域在最新的{}之间</li><li>如果在<code>let a</code> 之前使用了a，那么报错</li><li>如果重复声明<code>let a</code>，那么报错</li></ol><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ol><li><code>let</code> 的作用域在最新的{}之间</li><li>如果在<code>let a</code> 之前使用了a，那么报错</li><li>如果重复声明<code>let a</code>，那么报错</li><li>只有一次赋值的机会，而且必须在声明的时候立马赋值</li></ol><h2 id="函数与对象的语法糖"><a href="#函数与对象的语法糖" class="headerlink" title="函数与对象的语法糖"></a>函数与对象的语法糖</h2><h3 id="将伪数组转为真数组方法"><a href="#将伪数组转为真数组方法" class="headerlink" title="将伪数组转为真数组方法"></a>将伪数组转为真数组方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function sum(message, ...numbers) &#123;</span><br><span class="line">  `let args = Array.prototype.slice.call(argumengs)` // ES5</span><br><span class="line">  `let args = Array.from(argumengs)` // ES6</span><br><span class="line">  `let args = [...argumeng]` // ES6</span><br><span class="line">  resule = numbers.reduce( (p , v ) =&gt; p + v, 0)</span><br><span class="line">  return message + result</span><br><span class="line">&#125;</span><br><span class="line">sum(&apos;结果是: &apos;, 1,2,3,4,5) // 15</span><br></pre></td></tr></table></figure><h3 id="展开操作"><a href="#展开操作" class="headerlink" title="展开操作"></a>展开操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...iterableObj] = [1, 3, 5, 7, 9]; </span><br><span class="line">[0, 2, `...iterableObj`, 4, 6, 8];</span><br></pre></td></tr></table></figure><h3 id="结构赋值"><a href="#结构赋值" class="headerlink" title="结构赋值"></a>结构赋值</h3><blockquote><p>[a, b] = [b, a]<br>[a, b, …rest] = [10, 20, 30, 40, 50]<br>let {name, age} = frank<br>[a=5, b=7] = [1];<br>[a, b] = f()<br>[a, , b] = f();<br>{p: foo, q: bar} = o<br>let {a = 10, b = 5} = {a: 3};<br>let {a:aa = 10, b:bb = 5} = {a: 3};<br>对象浅拷贝</p><ul><li>let objB = Object.assign({}, objA) // ES5</li><li>let objB = <code>{...objA}</code> // ES6<br>对象合并</li><li>let objB = Object.assign({}, objA, objC) // ES5</li><li>let objB = <code>{...objA, ...objC}</code> // ES6</li></ul></blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC" target="_blank" rel="noopener">MDN 上更多的例子</a></p><h3 id="对象属性加强"><a href="#对象属性加强" class="headerlink" title="对象属性加强"></a>对象属性加强</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj = &#123; x, y &#125; // obj = &#123;x:x, y: y&#125;</span><br><span class="line">obj = &#123;[&quot;baz&quot; + quux() ]: 42&#125;</span><br><span class="line">函数属性可以缩写</span><br></pre></td></tr></table></figure><h2 id="新的字符串"><a href="#新的字符串" class="headerlink" title="新的字符串"></a>新的字符串</h2><ol><li>多行字符串<strong><code></code></strong></li><li>字符串里插入变量（插值）<strong><code>${}</code></strong></li><li>函数接字符串<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn`$&#123;name&#125; 是一个 $&#123;person&#125;`</span><br></pre></td></tr></table></figure></li></ol><h2 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function makeIterator() &#123;</span><br><span class="line">  var _value = 0</span><br><span class="line">  var max = 10</span><br><span class="line">  return &#123;</span><br><span class="line">    next: function() &#123;</span><br><span class="line">      _value += 1</span><br><span class="line">      if(_value &gt; max) &#123;throw new Errow(&apos;超出最大值&apos;)&#125;</span><br><span class="line"></span><br><span class="line">      if(_value === max) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          value: _value,</span><br><span class="line">          done: true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          value: _value</span><br><span class="line">          done: false</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a = makeIterator()</span><br><span class="line">a.next() // 超出10之后就提示错误</span><br></pre></td></tr></table></figure></p><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>生成器函数提供了一个强大的选择：它允许你定义一个包含自有迭代算法的函数， 同时它可以自动维护自己的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function* makeRangeIterator(start = 0, end = 100, step = 1) &#123;</span><br><span class="line">    for (let i = start; i &lt; end; i += step) &#123;</span><br><span class="line">        yield i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h3><p>使用<code>for...of</code>循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。<br>实现可迭代 <code>Symbol.iterator</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var myIterable = &#123;</span><br><span class="line">  *[Symbol.iterator]() &#123;</span><br><span class="line">    yield 1;</span><br><span class="line">    yield 2;</span><br><span class="line">    yield 3;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let value of myIterable) &#123; </span><br><span class="line">    console.log(value); </span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><ol><li><code>let a = Symbol()</code> Symbol是一个全局属性</li><li>不能使用<code>new Symbol()</code></li><li>从Symbol()返回的symbol值都是唯一的 Symbol() !== Symbol()</li><li>Symbol创建一个私有属性 Object[Symbol()] === xxx</li></ol><h3 id="Set对象"><a href="#Set对象" class="headerlink" title="Set对象"></a>Set对象</h3><p>储存任何对象的的唯一值，无论原始值或者是对象引用</p><p><strong>数组去重：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3,5,6,3,5,2,4,2,2,3]</span><br><span class="line"></span><br><span class="line">function uniq(array) &#123;</span><br><span class="line">  var result = []</span><br><span class="line">  var hash = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  for(let i =0; i &lt; array.length; i++) &#123;</span><br><span class="line">    hash[array[i]] = true</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for(let key in hash) &#123;</span><br><span class="line">    result.push(key)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line">uniq(a)</span><br></pre></td></tr></table></figure></p><p><strong>缺点：</strong></p><ul><li>无法区分数字或字符串</li><li>不能去重对象</li></ul><p><strong>去重优化：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3,5,6,3,5,2,4,2,2,3]</span><br><span class="line"></span><br><span class="line">function uniq(array) &#123;</span><br><span class="line">  return Array.from(new Set(array)) // ES6 转化数组</span><br><span class="line">  return [...new Set(array)] // 第二种方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uniq(a)</span><br></pre></td></tr></table></figure></p><h3 id="Map对象"><a href="#Map对象" class="headerlink" title="Map对象"></a>Map对象</h3><p>Map对象保存键值对，任何值都可以作为一个键或一个值<br><code>var a = new Map()</code></p><h2 id="ES6-对象新语法"><a href="#ES6-对象新语法" class="headerlink" title="ES6 对象新语法"></a>ES6 对象新语法</h2><h3 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h3><p>通过<code>new Object()</code>， <code>Object.create()</code>方法，或者使用<code>字面量标记</code>（初始化标记）初始化对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let obj = &#123;&#125;</span><br><span class="line">let obj2 = new Object&#123;&#125;</span><br><span class="line">let obj3 = Object.create(Object.prototype)</span><br><span class="line">let obj4 = Object.create(null)</span><br><span class="line"></span><br><span class="line">var o = &#123;</span><br><span class="line">  property([parameters]) &#123;&#125;,</span><br><span class="line">  get property() &#123;&#125;,</span><br><span class="line">  set property(value) &#123;&#125;,</span><br><span class="line">  * generator() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var i = 0;</span><br><span class="line">var a = &#123;</span><br><span class="line">  [&quot;foo&quot; + ++i]: i,</span><br><span class="line">  [&quot;foo&quot; + ++i]: i,</span><br><span class="line">  [&quot;foo&quot; + ++i]: i</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(a.foo1); // 1</span><br><span class="line">console.log(a.foo2); // 2</span><br><span class="line">console.log(a.foo3); // 3</span><br><span class="line"></span><br><span class="line">var param = &apos;size&apos;;</span><br><span class="line">var config = &#123;</span><br><span class="line">  [param]: 12,</span><br><span class="line">  [&quot;mobile&quot; + param.charAt(0).toUpperCase() + param.slice(1)]: 4</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(config); // &#123; size: 12, mobileSize: 4 &#125;</span><br></pre></td></tr></table></figure><h2 id="ES6-模块"><a href="#ES6-模块" class="headerlink" title="ES6 模块"></a>ES6 模块</h2><p>导入: <code>import</code></p><blockquote><p>import defaultExport from “module-name”;<br>import <em> as name from “module-name”;<br>import { export } from “module-name”;<br>import { export as alias } from “module-name”;<br>import { export1 , export2 } from “module-name”;<br>import { foo , bar } from “module-name/path/to/specific/un-exported/file”;<br>import { export1 , export2 as alias2 , […] } from “module-name”;<br>import defaultExport, { export [ , […] ] } from “module-name”;<br>import defaultExport, </em> as name from “module-name”;<br>import “module-name”;</p></blockquote><p>导出: <code>export</code></p><blockquote><p>export { name1, name2, …, nameN };<br>export { variable1 as name1, variable2 as name2, …, nameN };<br>export default expression;<br>export { default } from …;</p></blockquote><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>类：实际上是个“特殊的函数”，<strong>拥有相同属性的对象</strong>类语法有两个组成部分：类表达式和类声明。<br>构造函数： <strong>用来创建某个类的对象的函数</strong><br><code>new</code><br><code>get</code><br><code>set</code><br><code>constructor</code>：指向对象的原型的属性<br><code>static</code>：关键字用来定义一个类的一个静态方法<br><code>extends</code>：关键字在类声明或类表达式中用于创建一个类作为另一个类的一个子类<br><code>super</code>： 关键字用于调用对象的父对象上的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Rectangle &#123;</span><br><span class="line">    // constructor </span><br><span class="line">    constructor(height, width) &#123;</span><br><span class="line">        this.height = height;</span><br><span class="line">        this.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">    // Getter</span><br><span class="line">    get area() &#123;</span><br><span class="line">        return this.calcArea()</span><br><span class="line">    &#125;</span><br><span class="line">    // Method</span><br><span class="line">    calcArea() &#123;</span><br><span class="line">        return this.height * this.width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const square = new Rectangle(10, 10);</span><br><span class="line"></span><br><span class="line">console.log(square.area);</span><br><span class="line">// 100</span><br></pre></td></tr></table></figure><h2 id="Promise回调"><a href="#Promise回调" class="headerlink" title="Promise回调"></a>Promise回调</h2><ol><li><p>回调</p><ul><li>把一个函数A传给另一个函数B调用，那么A就是回调函数</li><li>缺点1：回调地狱</li><li>缺点2：不知道怎么使用 Node/jQuery —— 只能强行背下来</li></ul></li><li><p>Promise<br>对象用于表示一个异步操作的最终状态（完成或失败），以及该异步操作的结果值。<br>语法：<br><code>new Promise( function(resolve, reject) {...} /* executor */  );</code></p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var promise1 = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    resolve(&apos;foo&apos;);</span><br><span class="line">  &#125;, 300);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise1.then(function(value) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">  // expected output: &quot;foo&quot;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(promise1);</span><br><span class="line">// expected output: [object Promise]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>HTTP高级</title>
      <link href="/2019/07/26/HTTP%E9%AB%98%E7%BA%A7/"/>
      <url>/2019/07/26/HTTP%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="Cookie-和-Session-的区别"><a href="#Cookie-和-Session-的区别" class="headerlink" title="Cookie 和 Session 的区别"></a>Cookie 和 Session 的区别</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><ol><li>服务器通过<code>Set-Cookie</code> 头给客户端一串字符串</li><li>客户端每次访问相同域名的网页时，必须带上这串字符串</li><li>客户端要在一小段时间内保持这个Cookie</li><li>Cookie 默认在用户关闭页面后就失效，后台代码可以任意设置Cookie的过期时间</li></ol><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><ol><li>将<code>SessionID</code>（随机数）通过Cookie发给客户端</li><li>客户端访问服务器时，服务器读取<code>SessionID</code></li><li>服务器有一小块内存（哈希表）保存了所有的session</li><li>通过<code>SeesionID</code> 我们可以得到对应用户的隐私信息，如ID,Email</li><li>这个内存（哈希表）就是服务器上的所有session</li></ol><p>区别：<br><strong>Session是基于Cookie实现的，使用Session防止用户cookie被篡改</strong><br><strong>Cookie 保存在客户端，每次都随请求发送给 Server</strong><br><strong>Session 保存在 Server 的内存里，其 Session ID 是通过 Cookie 发送给客户端的</strong></p><h2 id="Cookie-和-LocalStorage-的区别"><a href="#Cookie-和-LocalStorage-的区别" class="headerlink" title="Cookie 和 LocalStorage 的区别"></a>Cookie 和 LocalStorage 的区别</h2><p>区别：<br><strong>Cookie</strong>是通过服务器使用HTTP协议进行cookie存储<br><strong>LocalStorage</strong> 跟 <strong>HTTP</strong> 无关，HTTP 不会带上 LocalStorage的值<br><strong>LocalStorage</strong> 的大小限制比 <strong>Cookie</strong> 大多了</p><h2 id="LocalStorage-和-SessionStorage-的区别"><a href="#LocalStorage-和-SessionStorage-的区别" class="headerlink" title="LocalStorage 和 SessionStorage 的区别"></a>LocalStorage 和 SessionStorage 的区别</h2><h3 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h3><ol><li>LocalStorage 跟 HTTP 无关</li><li>HTTP 不会带上 LocalStorage的值</li><li>只有相同域名的页面才能互相读取 LocalStorage （没有同源那么严格）</li><li>每个域名 LocalStorage 最大存储量为 5MB 左右 （每个浏览器不一样）</li><li>常用场景： 记录有没有提示过用户（主要是记录没有用的信息，不能记录密码）</li><li>LocalStorage 永久有效， 除非用户清理缓存</li></ol><h3 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h3><ol><li>LocalStorage 跟 HTTP 无关</li><li>HTTP 不会带上 LocalStorage的值</li><li>只有相同域名的页面才能互相读取 LocalStorage （没有同源那么严格）</li><li>每个域名 LocalStorage 最大存储量为 5MB 左右 （每个浏览器不一样）</li></ol><p>区别：<br><strong>LocalStorage 永久有效， 除非用户清理缓存</strong><br><strong>SessionStorage 在用户关闭页面（会话结束）后就失效</strong></p><h2 id="Cookie-如何设置过期时间？"><a href="#Cookie-如何设置过期时间？" class="headerlink" title="Cookie 如何设置过期时间？"></a>Cookie 如何设置过期时间？</h2><ul><li>通过max-age,将max-age设置为正数的时候,数值即为cookie的有效时间,设置为负数或零就可以将cookie删除.</li><li>通过expires来设置,但时间格式要用GMT或者UTC来表示</li></ul><h2 id="如何删除-Cookie？"><a href="#如何删除-Cookie？" class="headerlink" title="如何删除 Cookie？"></a>如何删除 Cookie？</h2><blockquote><ol><li>打开Chrome浏览器 。 …</li><li>点击Chrome浏览器右上角的⋮。 屏幕上会出现一个下拉菜单。</li><li>选择靠近菜单底部的更多工具。 …</li><li>点击靠近弹出菜单顶端的清除浏览数据，在新的标签页中打开浏览数据偏好设置。</li><li>一定要勾选“Cookie及其它网站数据”。 …</li><li>选择时间不限。 …</li><li>点击窗口右下角的清除数据，删除浏览器的所有Cookie。</li></ol></blockquote><h2 id="Cache-Control-max-age-1000-缓存-与-ETag-的「缓存」有什么区别？"><a href="#Cache-Control-max-age-1000-缓存-与-ETag-的「缓存」有什么区别？" class="headerlink" title="Cache-Control: max-age=1000 缓存 与 ETag 的「缓存」有什么区别？"></a>Cache-Control: max-age=1000 缓存 与 ETag 的「缓存」有什么区别？</h2><p>区别：<br><code>Cache-Control: max-age=1000</code>是设置缓存1000毫秒内不发请求，超出后才发出请求。<br><code>Etag</code>是不下载文件，但还是要发出请求。发出请求后，检查<code>if-None-Match</code>信息，通过对比浏览器缓存文件的md5与服务器对应文件的md5是否一致,来确定是否可以利用缓存,只要md5一致,那么不会有响应体,直接用缓存</p><p>推荐优先使用<code>Cache-Control</code></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>JS高级基础知识</title>
      <link href="/2019/07/25/JS%E9%AB%98%E7%BA%A7%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/07/25/JS%E9%AB%98%E7%BA%A7%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var object = &#123;&#125;</span><br><span class="line">object.__proto__ === Object.prototype // 为 true</span><br><span class="line"></span><br><span class="line">var fn = function() &#123;&#125;</span><br><span class="line">fn.__proto__ === Function.prototype // 为 true</span><br><span class="line">fn.__proto__.__proto__ === Object.prototype // 为 true</span><br><span class="line"></span><br><span class="line">var array = []</span><br><span class="line">array.__proto__ === Array.prototype // 为 true</span><br><span class="line">array.__proto__.__proto__ === Object.prototype // 为 true</span><br><span class="line"></span><br><span class="line">Function.__proto__ === Function.prototype // 为 true</span><br><span class="line">Array.__proto__ === Function.prototype // 为 true</span><br><span class="line">Object.__proto__ === Function.prototype // 为 true</span><br><span class="line"></span><br><span class="line">true.__proto__ === Boolean.prototype // 为 true</span><br><span class="line"></span><br><span class="line">Function.prototype.__proto__ === Object.prototype // 为 true</span><br></pre></td></tr></table></figure><h2 id="new-Fn-会执行-Fn，并打印出-this，请问这个-this-有哪些属性？这个-this-的原型有哪些属性？"><a href="#new-Fn-会执行-Fn，并打印出-this，请问这个-this-有哪些属性？这个-this-的原型有哪些属性？" class="headerlink" title="new Fn() 会执行 Fn，并打印出 this，请问这个 this 有哪些属性？这个 this 的原型有哪些属性？"></a>new Fn() 会执行 Fn，并打印出 this，请问这个 this 有哪些属性？这个 this 的原型有哪些属性？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Fn() &#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">new Fn()</span><br></pre></td></tr></table></figure><ol><li>this 自身没有属性（只有一个隐藏的 <code>__proto__</code> 属性）；分为<strong>自有属性</strong>和<strong>共有属性</strong>。</li><li>this 的原型是 fn.prototype，只有一个属性 <code>constructor</code> ，且 constructor === fn（另外还有一个隐藏属性 <code>__proto__</code> ，指向 <strong>Object.prototype</strong>）</li></ol><h2 id="JSON-和-JavaScript-是什么关系？区别有哪些"><a href="#JSON-和-JavaScript-是什么关系？区别有哪些" class="headerlink" title="JSON 和 JavaScript 是什么关系？区别有哪些?"></a>JSON 和 JavaScript 是什么关系？区别有哪些?</h2><ul><li>JSON 和 JavaScript 是没有关系。</li><li>JSON 是一门抄袭/借鉴 JavaScript 的语言，同时也是一种数据交互格式，JSON 是 JavaScript 的子集（或者说 JSON 只抄袭了一部分 JavaScript 语法，而且没有新增任何原创的语法）</li></ul><p>区别： </p><ul><li>JSON是一种轻量级的数据交换格式。语法上严格遵守使用双引号 <code>&quot;</code> ，是一个字符串。 <strong>不支持</strong>函数、undefined、变量、引用、单引号字符串、对象的key不支持单引号也不支持不加引号、没有内置的 Date、Math、RegExp 等。</li><li>JavaScript是轻量级的脚本语言。并且JavaScript 全都支持。</li></ul><h2 id="MVC-是什么？"><a href="#MVC-是什么？" class="headerlink" title="MVC 是什么？"></a>MVC 是什么？</h2><p>MVC 是一种设计模式（或者软件架构），把系统分为三层：<strong>Model数据、View视图和Controller控制器</strong>。<br>Model 数据管理，包括数据逻辑、数据请求、数据存储等功能。前端 Model 主要负责 AJAX 请求或者 LocalStorage 存储<br>View 负责用户界面，前端 View 主要负责 HTML 渲染。<br>Controller 负责处理 View 的事件，并更新 Model；也负责监听 Model 的变化，并更新 View，Controller 控制其他的所有流程。</p><ul><li>控制器（Controller）- 负责转发请求，对请求进行处理。</li><li>视图（View） - 界面设计人员进行图形界面设计。</li><li>模型（Model） - 操作数据。程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。</li></ul><p>Model 和服务器交互，Model 将得到的数据交给 Controller，Controller 把数据填入 View，并监听 View<br>用户操作 View，如点击按钮，Controller 就会接受到点击事件，Controller 这时会去调用 Model，Model 会与服务器交互，得到数据后返回给 Controller，Controller 得到数据就去更新 View</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">!function() &#123;</span><br><span class="line">  var model = &#123;</span><br><span class="line">      data: null,</span><br><span class="line">      init() &#123;&#125;</span><br><span class="line">      fetch() &#123;&#125;</span><br><span class="line">      save() &#123;&#125;</span><br><span class="line">      update() &#123;&#125;</span><br><span class="line">      delete() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  view = &#123;</span><br><span class="line">      init() &#123;&#125;</span><br><span class="line">      template: &apos;&lt;h1&gt;hi&lt;/h1&apos; &gt;</span><br><span class="line">  &#125;</span><br><span class="line">  controller = &#123;</span><br><span class="line">      view: null,</span><br><span class="line">      model: null,</span><br><span class="line">      init(view, model) &#123;</span><br><span class="line">          this.view = view</span><br><span class="line">          this.model = model</span><br><span class="line">          this.bindEvents()</span><br><span class="line">      &#125;</span><br><span class="line">      render() &#123;</span><br><span class="line">          this.view.querySelector(&apos;name&apos;).innerText = this.model.data.name</span><br><span class="line">      &#125;,</span><br><span class="line">      bindEvents() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  controller.init(view, model)</span><br><span class="line">&#125;.call()</span><br></pre></td></tr></table></figure><h2 id="在-ES5-中如何用函数模拟一个类"><a href="#在-ES5-中如何用函数模拟一个类" class="headerlink" title="在 ES5 中如何用函数模拟一个类"></a>在 ES5 中如何用函数模拟一个类</h2><p>ES 5 没有 class 关键字，所以只能使用函数来模拟类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    this.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.gender = function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person(&apos;cai&apos;, &apos;16&apos;)</span><br></pre></td></tr></table></figure></p><p>上面代码就是一个最简单的类，Person 构造函数创建出来的对象自身有 name,age 属性，其原型上面有一个 gender 属性。</p><h2 id="创建一个返回-Promise-对象的函数"><a href="#创建一个返回-Promise-对象的函数" class="headerlink" title="创建一个返回 Promise 对象的函数"></a>创建一个返回 Promise 对象的函数</h2><p>利用JQuery使用<strong>AJAX异步调用函数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;url:&apos;/xxx&apos;, method:&apos;get&apos;&#125;).then(success1, error1).then(success2, error2)</span><br></pre></td></tr></table></figure></p><p>创建 Promise 对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function asyncMethod()&#123;</span><br><span class="line">    return new Promise(function (resolve, reject)&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            成功则调用 resolve</span><br><span class="line">            失败则调用 reject</span><br><span class="line">        &#125;,3000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>JSONP_跨域_AJAX</title>
      <link href="/2019/07/19/JSONP_%E8%B7%A8%E5%9F%9F_AJAX/"/>
      <url>/2019/07/19/JSONP_%E8%B7%A8%E5%9F%9F_AJAX/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h2><p>同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。<br><strong>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</strong><br>所谓”同源”指的是”三个相同”。</p><ul><li>协议相同</li><li>域名相同</li><li>端口相同</li></ul><h2 id="跨域有几种实现形式"><a href="#跨域有几种实现形式" class="headerlink" title="跨域有几种实现形式"></a>跨域有几种实现形式</h2><p>跨域有4种实现形式。</p><ol><li>jsonp</li><li>CORS</li><li>降域</li><li>postMessage</li></ol><h2 id="什么是-JSONP？"><a href="#什么是-JSONP？" class="headerlink" title="什么是 JSONP？"></a>什么是 JSONP？</h2><p>jsonp是便于客户端使用数据，逐渐形成了一种非正式传输协议。jsonp的核心则是动态添加<code>&lt;script&gt;</code>标签来调用服务器提供的js脚本。</p><h2 id="JSONP-为什么不支持-POST"><a href="#JSONP-为什么不支持-POST" class="headerlink" title="JSONP 为什么不支持 POST"></a>JSONP 为什么不支持 POST</h2><ol><li>因为JSONP是通过动态<code>&lt;script&gt;</code>创建的。</li><li>使用动态<code>&lt;script&gt;</code>后只能使用GET请求，不能使用POST请求。</li></ol><h2 id="什么是CORS"><a href="#什么是CORS" class="headerlink" title="什么是CORS"></a>什么是CORS</h2><p>CORS 全称是<strong>跨域资源共享</strong>（<code>Cross-Origin Resource Sharing</code>），是一种 <em>AJAX</em> 跨域请求资源的方式，当你使用 <strong>XMLHttpRequest</strong> 发送请求时，浏览器发现该请求不符合同源策略，会给该请求加一个请求头：Origin，后台进行一系列处理，如果确定接受请求则在返回结果中加入一个响应头：<code>Access-Control-Allow-Origin</code>; 浏览器判断该相应头中是否包含 Origin 的值.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//  AJAX请求</span><br><span class="line">let request = new XMLHttpRequest()</span><br><span class="line">  request.open(&apos;GET&apos;, &apos;/xxx&apos;)</span><br><span class="line">  request.send()</span><br><span class="line">  request.onreadystatechange(() =&gt; &#123;</span><br><span class="line">    if (request.readyState === 4) &#123;</span><br><span class="line">      if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) &#123;</span><br><span class="line">        let string = request.responseText</span><br><span class="line">        let object = JSON.parse(string)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if(request.status &gt;= 400) &#123;</span><br><span class="line">      console.log(&apos;请求失败&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h2 id="AJAX-的所有功能"><a href="#AJAX-的所有功能" class="headerlink" title="AJAX 的所有功能"></a>AJAX 的所有功能</h2><ul><li>客户端的JS发起请求（浏览器上的）</li><li>服务端的JS发送响应（Node.js上的）</li></ul><ol><li><p>JS 可以设置任意请求 header 吗<br>第一部分 request.open(‘get’, ‘/xxx’)<br>第二部分 request.setRequestHeader(‘content-type’,’x-www-form-urlencoded’)<br>第四部分 request.send(‘a=1&amp;b=2’)</p></li><li><p>JS 可以获取任意响应 header 吗？<br>第一部分 request.status / request.statusText<br>第二部分 request.getResponseHeader() / request.getAllResponseHeaders()<br>第四部分 request.responseText</p></li></ol><h2 id="使用JQuery的异步请求"><a href="#使用JQuery的异步请求" class="headerlink" title="使用JQuery的异步请求"></a>使用JQuery的异步请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">JQuery.ajax(&#123;url, method, body, success, fail&#125;) &#123;</span><br><span class="line">    let request = new XMLHttpRequest()</span><br><span class="line">    request.open(method, url)</span><br><span class="line">    request.onreadystatechange = () =&gt; &#123;</span><br><span class="line">        if (request.readyState === 4) &#123;</span><br><span class="line">            if(request.status &gt;= 200 &amp;&amp; request.status &lt; 300) &#123;</span><br><span class="line">                success.call(undefined, request.responseText)</span><br><span class="line">            &#125; else if (request.status &gt; 400) &#123;</span><br><span class="line">                fail.call(undefined, request)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    request.send(body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Promise规则封装-jQuery-ajax"><a href="#使用Promise规则封装-jQuery-ajax" class="headerlink" title="使用Promise规则封装 jQuery.ajax"></a>使用Promise规则封装 jQuery.ajax</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = function(&#123;url, method&#125;) &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    let request = new XMLHttpRequest()</span><br><span class="line">    request.open(method, url)</span><br><span class="line">    request.onreadystatechange = () =&gt; &#123;</span><br><span class="line">      if (request.readyState === 4) &#123;</span><br><span class="line">          if(request.status &gt;= 200 &amp;&amp; request.status &lt; 300) &#123;</span><br><span class="line">              resolve.call(undefined, request.responseText)</span><br><span class="line">          &#125; else if (request.status &gt; 400) &#123;</span><br><span class="line">              reject.call(undefined, request)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    request.send()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>面试题</title>
      <link href="/2019/07/15/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/07/15/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="请写出一个符合-W3C-规范的-HTML-文件，要求"><a href="#请写出一个符合-W3C-规范的-HTML-文件，要求" class="headerlink" title="请写出一个符合 W3C 规范的 HTML 文件，要求"></a>请写出一个符合 W3C 规范的 HTML 文件，要求</h2><ol><li>页面标题为「我的页面」</li><li>页面中引入了一个外部 CSS 文件，文件路径为 /style.css</li><li>页面中引入了另一个外部 CSS 文件，路径为 /print.css，该文件仅在打印时生效</li><li>页面中引入了另一个外部 CSS 文件，路径为 /mobile.css，该文件仅在设备宽度小于 500 像素时生效</li><li>页面中引入了一个外部 JS 文件，路径为 /main.js</li><li>页面中引入了一个外部 JS 文件，路径为 /gbk.js，文件编码为 GBK</li><li>页面中有一个 SVG 标签，SVG 里面有一个直径为 100 像素的圆圈，颜色随意</li><li>注意题目中的路径</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;我的页面&lt;/title&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;./style.css&quot;&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;./print.css&quot; media=&quot;print&quot;&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;./mobile.css&quot; media=&quot;screen and (max-width:500px)&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;svg width=&quot;200px&quot; height=&quot;200px&quot;&gt;</span><br><span class="line">      &lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;50&quot; fill=&quot;yellow&quot;/&gt;</span><br><span class="line">  &lt;/svg&gt;</span><br><span class="line">&lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./gbk.js&quot; charset=&quot;GBK&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="移动端是怎么做适配的？"><a href="#移动端是怎么做适配的？" class="headerlink" title="移动端是怎么做适配的？"></a>移动端是怎么做适配的？</h2><ol><li>meta viewport</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>媒体查询</li></ol><p>如果满足媒体查询中的条件，设置生效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@media (min-width: 960px) &#123;</span><br><span class="line"></span><br><span class="line">​    body &#123;</span><br><span class="line"></span><br><span class="line">​        background: red</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// 如果媒体查询满足不小于960px的条件，则body背景色变红色</span><br></pre></td></tr></table></figure></p><ol start="3"><li>动态 rem 方案</li></ol><p>移动端自适应rem</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">        var scale = 1 / window.devicePixelRatio;</span><br><span class="line"></span><br><span class="line">        document.write(`&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=$&#123;scale&#125;, maximum-scale=$&#123;scale&#125;, minimum-scale=$&#123;scale&#125;&quot;&gt;`)</span><br><span class="line"></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line"></span><br><span class="line">        var width = document.documentElement.clientWidth / window.devicePixelRatio;</span><br><span class="line"></span><br><span class="line">        var css = `</span><br><span class="line"></span><br><span class="line">            html&#123;</span><br><span class="line"></span><br><span class="line">                font-size: $&#123;width / 10 * window.devicePixelRatio&#125;px;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        `</span><br><span class="line"></span><br><span class="line">        document.write(`&lt;style&gt;$&#123;css&#125;&lt;/style&gt;`)</span><br><span class="line"></span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><p><a href="https://bloglive.top/demo/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%87%AA%E9%80%82%E5%BA%94rem/index.html" target="_blank" rel="noopener">移动端rem</a></p><h2 id="实现圆角矩形和阴影怎么做"><a href="#实现圆角矩形和阴影怎么做" class="headerlink" title="实现圆角矩形和阴影怎么做?"></a>实现圆角矩形和阴影怎么做?</h2><ol><li>圆角矩形(<strong>border-radius</strong>)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-radius: 25px</span><br></pre></td></tr></table></figure></li></ol><p>2, 阴影(<strong>box-shadow</strong>)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box-shadow: 3px 4px 5px 0px rgba(0,0,0,0.75);</span><br></pre></td></tr></table></figure></p><p><a href="http://js.jirengu.com/qetecesiyi/2/edit" target="_blank" rel="noopener">demo</a></p><h2 id="什么是闭包，闭包的用途是什么？"><a href="#什么是闭包，闭包的用途是什么？" class="headerlink" title="什么是闭包，闭包的用途是什么？"></a>什么是闭包，闭包的用途是什么？</h2><p><strong>函数和函数内部能够访问外部变量的环境，就是闭包。</strong><br>闭包的用途：</p><pre><code>1. 隐藏一个变量。2. 函数作用域下，保护内部变量不受外部影响的机制。</code></pre><h2 id="call、apply、bind-的用法分别是什么？"><a href="#call、apply、bind-的用法分别是什么？" class="headerlink" title="call、apply、bind 的用法分别是什么？"></a>call、apply、bind 的用法分别是什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun.call(thisArg, arg1, arg2, ...)</span><br><span class="line">func.apply(thisArg, [argsArray])</span><br><span class="line">function.bind(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//Demo with javascript .call()</span><br><span class="line"></span><br><span class="line">var obj = &#123;name:&quot;Niladri&quot;&#125;;</span><br><span class="line"></span><br><span class="line">var greeting = function(a,b,c)&#123;</span><br><span class="line">    return &quot;welcome &quot;+this.name+&quot; to &quot;+a+&quot; &quot;+b+&quot; in &quot;+c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(greeting.call(obj,&quot;Newtown&quot;,&quot;KOLKATA&quot;,&quot;WB&quot;));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//Demo with javascript .apply()</span><br><span class="line"></span><br><span class="line">var obj = &#123;name:&quot;Niladri&quot;&#125;;</span><br><span class="line"></span><br><span class="line">var greeting = function(a,b,c)&#123;</span><br><span class="line">    return &quot;welcome &quot;+this.name+&quot; to &quot;+a+&quot; &quot;+b+&quot; in &quot;+c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// array of arguments to the actual function</span><br><span class="line">var args = [&quot;Newtown&quot;,&quot;KOLKATA&quot;,&quot;WB&quot;];  </span><br><span class="line">console.log(&quot;Output using .apply() below &quot;)</span><br><span class="line">console.log(greeting.apply(obj,args));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//Use .bind() javascript</span><br><span class="line"></span><br><span class="line">var obj = &#123;name:&quot;Niladri&quot;&#125;;</span><br><span class="line"></span><br><span class="line">var greeting = function(a,b,c)&#123;</span><br><span class="line">    return &quot;welcome &quot;+this.name+&quot; to &quot;+a+&quot; &quot;+b+&quot; in &quot;+c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//creates a bound function that has same body and parameters </span><br><span class="line">var bound = greeting.bind(obj); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.dir(bound); ///returns a function</span><br><span class="line"></span><br><span class="line">console.log(&quot;Output using .bind() below &quot;);</span><br><span class="line"></span><br><span class="line">console.log(bound(&quot;Newtown&quot;,&quot;KOLKATA&quot;,&quot;WB&quot;)); //call the bound function</span><br></pre></td></tr></table></figure><h2 id="请说出至少-8-个-HTTP-状态码，并描述各状态码的意义。"><a href="#请说出至少-8-个-HTTP-状态码，并描述各状态码的意义。" class="headerlink" title="请说出至少 8 个 HTTP 状态码，并描述各状态码的意义。"></a>请说出至少 8 个 HTTP 状态码，并描述各状态码的意义。</h2><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><ol><li>1xx消息<br>代表请求已被接受，需要继续处理</li><li>2xx成功<br>代表请求已成功被服务器接收、理解、并接受</li><li>3xx重定向<br>代表需要客户端采取进一步的操作才能完成请求</li><li>4xx客户端错误<br>代表了客户端看起来可能发生了错误，妨碍了服务器的处理</li><li>5xx服务器错误<br>表示服务器无法完成明显有效的请求</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">200---(成功) 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</span><br><span class="line">201---(已创建) 请求成功并且服务器创建了新的资源。</span><br><span class="line">301---(永久移动)请求的网页已永久移动到新位置.服务器返回此响应(对 GET 或 HEAD 请求的响应)时,会自动将请求者转到新位置</span><br><span class="line">304---(未修改)自从上次请求后,请求的网页未修改过.服务器返回此响应时,不会返回网页内容</span><br><span class="line">403---(禁止)服务器拒绝请求</span><br><span class="line">404---(未找到)服务器找不到请求的网页</span><br><span class="line">500---(服务器内部错误)服务器遇到错误,无法完成请求</span><br><span class="line">503---(服务不可用)服务器目前无法使用(由于超载或停机维护)</span><br></pre></td></tr></table></figure><h2 id="请写出一个-HTTP-post-请求的内容，包括四部分。其中"><a href="#请写出一个-HTTP-post-请求的内容，包括四部分。其中" class="headerlink" title="请写出一个 HTTP post 请求的内容，包括四部分。其中"></a>请写出一个 HTTP post 请求的内容，包括四部分。其中</h2><ol><li>第四部分的内容是 username=ff&amp;password=123</li><li>第二部分必须含有 Content-Type 字段</li><li>请求的路径为 /path</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 POST /path  HTTP/1.1</span><br><span class="line">2 key: value</span><br><span class="line">2 key: value</span><br><span class="line">2 Content-Type: application/x-www-form-urlencoded</span><br><span class="line">3</span><br><span class="line">4 username=ff&amp;password=123</span><br></pre></td></tr></table></figure><h2 id="请说出至少三种排序的思路，这三种排序的时间复杂度分别为"><a href="#请说出至少三种排序的思路，这三种排序的时间复杂度分别为" class="headerlink" title="请说出至少三种排序的思路，这三种排序的时间复杂度分别为"></a>请说出至少三种排序的思路，这三种排序的时间复杂度分别为</h2><ol><li>O(n*n)</li><li>O(n log2 n)</li><li>O(n + max) </li></ol><h3 id="O-n-n-冒泡排序"><a href="#O-n-n-冒泡排序" class="headerlink" title="O(n*n) 冒泡排序"></a>O(n*n) 冒泡排序</h3><p>冒泡排序，重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    for (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        for (var j = 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j+1]) &#123;        // 相邻元素两两对比</span><br><span class="line">                var temp = arr[j+1];        // 元素交换</span><br><span class="line">                arr[j+1] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="O-n-log2-n-快速排序"><a href="#O-n-log2-n-快速排序" class="headerlink" title="O(n log2 n)快速排序"></a>O(n log2 n)快速排序</h3><p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为较小和较大的2个子序列，然后递归地排序两个子序列。</p><pre><code>步骤为：1. 挑选基准值：从数列中挑出一个元素，称为“基准”（pivot），2. 分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成，3.  递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。</code></pre><h3 id="O-n-max-基数排序"><a href="#O-n-max-基数排序" class="headerlink" title="O(n + max) 基数排序"></a>O(n + max) 基数排序</h3><p>是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。</p><h2 id="一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？"><a href="#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？"></a>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h2><ol><li><p>DNS解析<br>一开始输入URL地址，如<code>www.baidu.com</code>，浏览器可能会进行一些预处理。浏览器回对URL进行检查，首先判断协议、判断URL的安全性… 最后进行DNS解析。</p><blockquote><p>浏览器缓存 – 浏览器会缓存DNS记录一段时间<br>系统缓存 – 从hosts文件里查找是否有该域名和对应IP<br>路由器缓存 – 一般路由器也会缓存域名信息<br>ISP DNS 缓存 – 比如到电信的DNS上查找缓存<br>如果都没有找到，则向根域名服务器查找域名对应IP，根域名服务器把请求转发到下一级，直到找到IP</p></blockquote></li><li><p>TCP链接<br><strong>然后建立TCP连接 – 三次握手</strong></p></li></ol><ul><li>主机向服务器发送一个建立连接的请求（您好，我想认识您）</li><li>服务器接到请求后发送同意连接的信号（好的，很高兴认识您）</li><li>主机接到同意连接的信号后，再次向服务器发送了确认信号（我也很高兴认识您），自此，主机与服务器两者建立了连接</li></ul><ol start="3"><li>发送HTTP请求</li></ol><ul><li>浏览器根据 URL 内容生成 HTTP 请求，请求中包含请求文件的位置、请求文件的方式等等</li><li>服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件</li><li>服务器将得到的 HTML 文件发送给浏览器</li><li>在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页</li><li>在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript等文件，过程同请求 HTML</li></ul><ol start="4"><li><p>服务器处理请求并返回HTTP报文<br>服务器的端口接收到请求报文，开始分析处理报文，查询服务器内是否存在符合请求要求的路径以及文件，返回响应报文；如果不存在此路径或者文件，则返回响应报文，状态码404等消息；如果有，则发送响应报文，包括HTTP协议、状态码200、响应报头、响应内容等；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 响应成功</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Bdpagetype: 2</span><br><span class="line">Bdqid: 0x8bf910690013ab7d</span><br><span class="line">Cache-Control: private</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Type: text/html;charset=utf-8</span><br><span class="line">Date: Mon, 15 Jul 2019 14:51:28 GMT</span><br><span class="line">Expires: Mon, 15 Jul 2019 14:51:27 GMT</span><br><span class="line">Server: BWS/1.1</span><br><span class="line">Set-Cookie: BDSVRTM=227; path=/</span><br><span class="line">Set-Cookie: BD_HOME=1; path=/</span><br><span class="line">Set-Cookie: H_PS_PSSID=1458_21103_20698_29522_29519_29237_28518_29098_28838_29220; path=/; domain=.baidu.com</span><br><span class="line">Strict-Transport-Security: max-age=172800</span><br><span class="line">X-Ua-Compatible: IE=Edge,chrome=1</span><br><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure></li><li><p>浏览器解析并渲染页面</p><blockquote><p>解析 HTML 标签, 构建 DOM 树<br>解析 CSS 标签, 构建 CSSOM 树<br>把 DOM 和 CSSOM 组合成 渲染树 (render tree)<br>在渲染树的基础上进行布局(layout), 计算每个节点的几何结构<br>把每个节点绘制到屏幕上 (painting)</p></blockquote></li><li>连接结束</li></ol><h2 id="实现数组去重？"><a href="#实现数组去重？" class="headerlink" title="实现数组去重？"></a>实现数组去重？</h2><ol><li>相邻元素去重(ES5)<br>这种方法首先调用了数组的排序方法sort()，然后根据排序后的结果进行遍历及相邻元素比对，如果相等则跳过改元素，直到遍历结束</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var array = [1,5,2,3,4,2,3,1,3,4]</span><br><span class="line"></span><br><span class="line">function unique(array) &#123;</span><br><span class="line">  if(!Array.isArray(array)) &#123;</span><br><span class="line">    console.log(&apos;type error!&apos;)</span><br><span class="line">    return </span><br><span class="line">  &#125;</span><br><span class="line">  array = array.sort()</span><br><span class="line">  let res = []</span><br><span class="line">  for(let i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    if(array[i] !== array[i - 1]) &#123;</span><br><span class="line">      res.push(array[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unique(array)</span><br></pre></td></tr></table></figure><ol start="2"><li>set与解构赋值去重(ES6)<br>ES6中新增了数据类型set，set的一个最大的特点就是数据不重复。Set函数可以接受一个数组（或类数组对象）作为参数来初始化，利用该特性也能做到给数组去重</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var array = [1,5,2,3,4,2,3,1,3,4]</span><br><span class="line"></span><br><span class="line">function unique(array) &#123;</span><br><span class="line">  if(!Array.isArray(array)) &#123;</span><br><span class="line">    console.log(&apos;type error!&apos;)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  return [...new Set(array)].sort()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unique(array)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>JS操作DOM常用API</title>
      <link href="/2019/07/07/JS%E6%93%8D%E4%BD%9CDOM%E5%B8%B8%E7%94%A8API/"/>
      <url>/2019/07/07/JS%E6%93%8D%E4%BD%9CDOM%E5%B8%B8%E7%94%A8API/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h3><p>Node类型中，我们最常用的就是element，text，attribute，comment，document，document_fragment这几种类型。</p><h3 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h3><p>Element提供了对元素标签名，子节点和特性的访问，我们常用HTML元素比如div，span，a等标签就是element中的一种。</p><p><strong>特性：</strong><br>(1) <code>nodeType为1</code><br>(2) <code>nodeName为元素标签名，tagName也是返回标签名</code><br>(3) <code>nodeValue为null</code><br>(4) <code>parentNode可能是Document或Element</code><br>(5) <code>子节点可能是Element，Text，Comment，Processing_Instruction，CDATASection或EntityReference</code></p><h3 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h3><p>Text表示文本节点，它包含的是纯文本内容，不能包含html代码，但可以包含转义后的html代码。<br><strong>特性：</strong><br>(1) <code>nodeType为3</code><br>(2) <code>nodeName为#text</code><br>(3) <code>nodeValue为文本内容</code><br>(4) <code>parentNode是一个Element</code><br>(5) <code>没有子节点</code></p><h3 id="Attr类型"><a href="#Attr类型" class="headerlink" title="Attr类型"></a>Attr类型</h3><p>Attr类型表示元素的特性，相当于元素的attributes属性中的节点。<br><strong>特性：</strong><br>(1) <code>nodeType值为2</code><br>(2) <code>nodeName是特性的名称</code><br>(3) <code>nodeValue是特性的值</code><br>(4) <code>parentNode为null</code></p><h3 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a>Comment类型</h3><p>Comment表示HTML文档中的注释。<br><strong>特性：</strong><br>(1) <code>nodeType为8</code><br>(2) <code>nodeName为#comment</code><br>(3) <code>nodeValue为注释的内容</code><br>(4) <code>parentNode可能是Document或Element</code><br>(5) <code>没有子节点</code></p><h3 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h3><p>Document表示文档，在浏览器中，document对象是HTMLDocument的一个实例，表示整个页面，它同时也是window对象的一个属性。<br><strong>特性：</strong><br>(1) <code>nodeType为9</code><br>(2) <code>nodeName为#document</code><br>(3) <code>nodeValue为null</code><br>(4) <code>parentNode为null</code><br>(5) <code>子节点可能是一个DocumentType或Element</code></p><h3 id="DocumentFragment类型"><a href="#DocumentFragment类型" class="headerlink" title="DocumentFragment类型"></a>DocumentFragment类型</h3><p>DocumentFragment是所有节点中唯一一个没有对应标记的类型，它表示一种轻量级的文档，可能当作一个临时的仓库用来保存可能会添加到文档中的节点。<br><strong>特性：</strong><br>(1) <code>nodeType为11</code><br>(2) <code>nodeName为#document-fragment</code><br>(3) <code>nodeValue为null</code><br>(4) <code>parentNode为null</code></p><h2 id="节点创建型api"><a href="#节点创建型api" class="headerlink" title="节点创建型api"></a>节点创建型api</h2><h3 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h3><p>通过传入指定的一个标签名来创建一个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var div = document.createElement(&quot;div&quot;);</span><br></pre></td></tr></table></figure></p><h3 id="createTextNode"><a href="#createTextNode" class="headerlink" title="createTextNode"></a>createTextNode</h3><p>创建一个文本节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var textNode = document.createTextNode(&quot;一个TextNode&quot;);</span><br></pre></td></tr></table></figure></p><h3 id="cloneNode"><a href="#cloneNode" class="headerlink" title="cloneNode"></a>cloneNode</h3><p>返回调用方法的节点的一个副本，它接收一个bool参数，用来表示是否复制子元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var parent = document.getElementById(&quot;parentElement&quot;);</span><br><span class="line">var parent2 = parent.cloneNode(true);// 传入true</span><br><span class="line">parent2.id = &quot;parent2&quot;;</span><br></pre></td></tr></table></figure></p><h3 id="createDocumentFragment"><a href="#createDocumentFragment" class="headerlink" title="createDocumentFragment"></a>createDocumentFragment</h3><p>用来创建一个DocumentFragment<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fragment = document.createDocumentFragment();</span><br></pre></td></tr></table></figure></p><h3 id="创建型API总结"><a href="#创建型API总结" class="headerlink" title="创建型API总结"></a>创建型API总结</h3><ol><li><p>它们创建的节点只是一个孤立的节点，要通过<code>appendChild</code>添加到文档中</p></li><li><p>cloneNode要注意如果被复制的节点是否包含子节点以及事件绑定等问题</p></li><li><p>使用createDocumentFragment来解决添加大量节点时的性能问题</p></li></ol><h2 id="页面修改型API"><a href="#页面修改型API" class="headerlink" title="页面修改型API"></a>页面修改型API</h2><p>修改页面内容的api主要包括：<strong>appendChild，insertBefore，removeChild，replaceChild</strong>。</p><h3 id="appendChild"><a href="#appendChild" class="headerlink" title="appendChild"></a>appendChild</h3><p>child节点将会作为parent节点的最后一个子节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.appendChild(child);</span><br></pre></td></tr></table></figure><h3 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore"></a>insertBefore</h3><p>insertBefore用来添加一个节点到一个参照节点之前<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parentNode.insertBefore(newNode,refNode);</span><br></pre></td></tr></table></figure></p><h3 id="removeChild"><a href="#removeChild" class="headerlink" title="removeChild"></a>removeChild</h3><p>删除指定的子节点并返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var deletedChild = parent.removeChild(node);</span><br></pre></td></tr></table></figure></p><h3 id="replaceChild"><a href="#replaceChild" class="headerlink" title="replaceChild"></a>replaceChild</h3><p>replaceChild用于使用一个节点替换另一个节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.replaceChild(newChild,oldChild);</span><br></pre></td></tr></table></figure></p><h2 id="页面修改型API总结"><a href="#页面修改型API总结" class="headerlink" title="页面修改型API总结"></a>页面修改型API总结</h2><ol><li><p>不管是新增还是替换节点，如果新增或替换的节点是原本存在页面上的，则其原来位置的节点将被移除，也就是说同一个节点不能存在于页面的多个位置</p></li><li><p>节点本身绑定的事件会不会消失，会一直保留着。</p></li></ol><h2 id="节点查询型API"><a href="#节点查询型API" class="headerlink" title="节点查询型API"></a>节点查询型API</h2><h3 id="document-getElementById"><a href="#document-getElementById" class="headerlink" title="document.getElementById"></a>document.getElementById</h3><p>根据元素id返回元素，返回值是Element类型，如果不存在该元素，则返回null。<br><strong>注意：</strong></p><ol><li><p>元素的Id是大小写敏感的，一定要写对元素的id</p></li><li><p>HTML文档中可能存在多个id相同的元素，则返回第一个元素</p></li><li><p>只从文档中进行搜索元素，如果创建了一个元素并指定id，但并没有添加到文档中，则这个元素是不会被查找到的</p></li></ol><h3 id="document-getElementsByTagName"><a href="#document-getElementsByTagName" class="headerlink" title="document.getElementsByTagName"></a>document.getElementsByTagName</h3><p>根据元素标签名获取元素，返回一个即时的HTMLCollection类型<br><strong>注意：</strong></p><ol><li><p>如果要对HTMLCollection集合进行循环操作，最好将其长度缓存起来，因为每次循环都会去计算长度，暂时缓存起来可以提高效率</p></li><li><p>如果没有存在指定的标签，该接口返回的不是null，而是一个空的HTMLCollection</p></li><li><p>“*”表示所有标签</p></li></ol><h3 id="document-getElementsByName"><a href="#document-getElementsByName" class="headerlink" title="document.getElementsByName"></a>document.getElementsByName</h3><p>主要是通过指定的name属性来获取元素，它返回一个即时的NodeList对象。<br><strong>注意：</strong></p><ol><li><p>返回对象是一个即时的NodeList，它是随时变化的</p></li><li><p>在HTML元素中，并不是所有元素都有name属性，比如div是没有name属性的，但是如果强制设置div的name属性，它也是可以被查找到的</p></li><li><p>在IE中，如果id设置成某个值，然后传入getElementsByName的参数值和id值一样，则这个元素是会被找到的，所以最好不好设置同样的值给id和name</p></li></ol><h3 id="document-getElementsByClassName"><a href="#document-getElementsByClassName" class="headerlink" title="document.getElementsByClassName"></a>document.getElementsByClassName</h3><p>这个API是根据元素的class返回一个即时的HTMLCollection<br><code>var elements = document.getElementsByClassName(names);</code><br><strong>注意：</strong></p><ol><li><p>返回结果是一个即时的HTMLCollection，会随时根据文档结构变化</p></li><li><p>IE9以下浏览器不支持</p></li><li><p>如果要获取2个以上classname，可传入多个classname，每个用空格相隔</p></li></ol><h3 id="document-querySelector和document-querySelectorAll"><a href="#document-querySelector和document-querySelectorAll" class="headerlink" title="document.querySelector和document.querySelectorAll"></a>document.querySelector和document.querySelectorAll</h3><p>这两个api很相似，通过css选择器来查找元素，注意选择器要符合CSS选择器的规则。<br><code>document.querySelector</code>返回<strong>第一个匹配的元素</strong>，如果没有匹配的元素，则返回null。<br><code>document.querySelectorAll</code>的不同之处在于它返回的是<strong>所有匹配的元素</strong>，而且可以匹配多个选择符<br><strong>注意：</strong></p><ol><li><p>querySelectorAll也是通过深度优先搜索，搜索的元素顺序和选择器的顺序无关</p></li><li><p>返回的是一个非即时的NodeList，也就是说结果不会随着文档树的变化而变化</p></li></ol><h2 id="节点关系型api"><a href="#节点关系型api" class="headerlink" title="节点关系型api"></a>节点关系型api</h2><h3 id="父关系型api"><a href="#父关系型api" class="headerlink" title="父关系型api"></a>父关系型api</h3><p><code>parentNode</code>：每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，Document或DocumentFragment。<br><code>parentElement</code>：返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element，如果不是，则返回null</p><h3 id="兄弟关系型api"><a href="#兄弟关系型api" class="headerlink" title="兄弟关系型api"></a>兄弟关系型api</h3><p><code>previousSibling</code>：节点的前一个节点，如果该节点是第一个节点，则为null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下。<br><code>previousElementSibling</code>：返回前一个元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持。<br><code>nextSibling</code>：节点的后一个节点，如果该节点是最后一个节点，则为null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下。<br><code>nextElementSibling</code>：返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持。</p><h3 id="子关系型api"><a href="#子关系型api" class="headerlink" title="子关系型api"></a>子关系型api</h3><p><code>childNodes</code>：返回一个即时的NodeList，表示元素的子节点列表，子节点可能会包含文本节点，注释节点等。<br><code>children</code>：一个即时的HTMLCollection，子节点都是Element，IE9以下浏览器不支持。<br><code>firstNode</code>：第一个子节点<br><code>lastNode</code>：最后一个子节点<br><code>hasChildNodes</code>方法：可以<strong>用来判断是否包含子节点。</strong></p><h3 id="元素属性型api"><a href="#元素属性型api" class="headerlink" title="元素属性型api"></a>元素属性型api</h3><h3 id="setAttribute"><a href="#setAttribute" class="headerlink" title="setAttribute"></a>setAttribute</h3><p>根据名称和值修改元素的特性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.setAttribute(name, value);</span><br></pre></td></tr></table></figure><h3 id="getAttribute"><a href="#getAttribute" class="headerlink" title="getAttribute"></a>getAttribute</h3><p>返回指定的特性名相应的特性值，如果不存在，则返回null或空字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var value = element.getAttribute(&quot;id&quot;);</span><br></pre></td></tr></table></figure></p><h2 id="元素样式型api"><a href="#元素样式型api" class="headerlink" title="元素样式型api"></a>元素样式型api</h2><h3 id="window-getComputedStyle"><a href="#window-getComputedStyle" class="headerlink" title="window.getComputedStyle"></a>window.getComputedStyle</h3><p>用来获取应用到元素后的样式，假设某个元素并未设置高度而是通过其内容将其高度撑开，这时候要获取它的高度就要用到getComputedStyle<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var style = window.getComputedStyle(element[, pseudoElt]);</span><br></pre></td></tr></table></figure></p><h3 id="getBoundingClientRect"><a href="#getBoundingClientRect" class="headerlink" title="getBoundingClientRect"></a>getBoundingClientRect</h3><p>返回元素的大小以及相对于浏览器可视窗口的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var clientRect = element.getBoundingClientRect();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>原型与原型链</title>
      <link href="/2019/07/06/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2019/07/06/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="全局对象-window"><a href="#全局对象-window" class="headerlink" title="全局对象 window"></a>全局对象 window</h2><p><strong>window 的属性就是全局变量。</strong><br><strong>window属性：</strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document" target="_blank" rel="noopener">window</a></p><h2 id="全局函数"><a href="#全局函数" class="headerlink" title="全局函数"></a>全局函数</h2><ol><li>Number<br><code>var n = new Number()</code>创建一个 Number 对象</li><li>String<br><code>var s = new String(&#39;hello&#39;)</code> 创建一个 String 对象</li><li>Boolean<br><code>var b = new Boolean(true)</code> 创建一个 Boolean 对象</li><li>Object<br><code>var o1 = {}</code> 创建一个 Object 对象<br><code>(var o2 = new Object()</code> 创建一个 Object 对象</li></ol><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p><strong>重要公式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var 对象 = new 函数()</span><br><span class="line"></span><br><span class="line">对象.__proto__ === 对象的构造函数.prototype</span><br><span class="line"></span><br><span class="line">// 推论</span><br><span class="line"></span><br><span class="line">var number = new Number()</span><br><span class="line"></span><br><span class="line">number.__proto__ = Number.prototype</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var object = new Object()</span><br><span class="line"></span><br><span class="line">object.__proto__ = Object.prototype</span><br><span class="line"></span><br><span class="line">var function = new Function()</span><br><span class="line"></span><br><span class="line">function.__proto__ = Function.prototype</span><br><span class="line"></span><br><span class="line">// 另外，所有函数都是由 Function 构造出来的，所以</span><br><span class="line"></span><br><span class="line">Number.__proto__ = Function.prototype // 因为 Number 是函数，是 Function 的实例</span><br><span class="line"></span><br><span class="line">Object.__proto__ = Function.prototype // 因为 Object 是函数，是 Function 的实例</span><br><span class="line"></span><br><span class="line">Function.__proto__ == Function.prototye // 因为 Function 是函数，是 Function 的实例！</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>JS里的数据类型转换</title>
      <link href="/2019/07/05/JS%E9%87%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2019/07/05/JS%E9%87%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="任意类型转字符串"><a href="#任意类型转字符串" class="headerlink" title="任意类型转字符串"></a>任意类型转字符串</h2><h3 id="String-x"><a href="#String-x" class="headerlink" title="String(x)"></a>String(x)</h3><p><img src="https://static.xiedaimala.com/FrpnWPAjH4_Zh1Ru58nEIC0I4onn" alt="图片"></p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p><img src="https://static.xiedaimala.com/FnbB3yikB790jzpavhE6eyqioUPP" alt="图片"></p><h3 id="0"><a href="#0" class="headerlink" title="+ 0"></a>+ 0</h3><p><img src="https://static.xiedaimala.com/FgaPxjEAu8-hzeBRnQ7jdHlZiw85" alt="图片"></p><h2 id="任意类型转为number"><a href="#任意类型转为number" class="headerlink" title="任意类型转为number"></a>任意类型转为number</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&apos;1&apos; -&gt; 1</span><br><span class="line">Number(&apos;1&apos;) === 1</span><br><span class="line">parseInt(&apos;1&apos;, 10) === 1</span><br><span class="line">parseFloat(&apos;1.23&apos;) === 1.23</span><br><span class="line">&apos;1&apos; + 0 === 1</span><br></pre></td></tr></table></figure><h2 id="任意类型转boolean"><a href="#任意类型转boolean" class="headerlink" title="任意类型转boolean"></a>任意类型转boolean</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Boolean(x)</span><br><span class="line">!!x</span><br></pre></td></tr></table></figure><h2 id="数据类型的false值"><a href="#数据类型的false值" class="headerlink" title="数据类型的false值"></a>数据类型的false值</h2><p> <code>0</code>、<code>NaN</code>、<code>false</code>、<code></code>、<code>undefined</code>、<code>null</code></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>JS里的数据类型</title>
      <link href="/2019/07/05/JS%E9%87%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/07/05/JS%E9%87%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript的七种数据类型"><a href="#JavaScript的七种数据类型" class="headerlink" title="JavaScript的七种数据类型"></a>JavaScript的七种数据类型</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>数值<code>number</code>、字符串<code>string</code>、布尔值<code>Boolean</code>、<code>symbol</code>、<code>undefined</code>、<code>null</code></p><h3 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a>复杂类型</h3><p>对象<code>object</code>— 狭义的对象<code>object</code>、数组<code>array</code>、函数<code>function</code></p><h2 id="null-和-undefined的区别"><a href="#null-和-undefined的区别" class="headerlink" title="null 和 undefined的区别"></a>null 和 undefined的区别</h2><ul><li>当变量没有赋值时— undefined</li><li>有对象<code>object</code>,但还没赋值 — null</li><li>有非对象<code>object</code>,不想赋值 — undefined</li></ul><h3 id="JavaScript三种方法确定数据类型"><a href="#JavaScript三种方法确定数据类型" class="headerlink" title="JavaScript三种方法确定数据类型"></a>JavaScript三种方法确定数据类型</h3><ol><li><p>typeof运算符</p></li><li><p>instanceof运算符</p></li><li><p>Object.prototype.toString方法</p></li></ol><h2 id="JavaScript内容详细内容"><a href="#JavaScript内容详细内容" class="headerlink" title="JavaScript内容详细内容"></a>JavaScript内容详细内容</h2><p>1、<a href="https://wangdoc.com/javascript/" target="_blank" rel="noopener">阮一峰JavaScript教程</a><br>2、<a href="http://javascript.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>CSS布局</title>
      <link href="/2018/12/11/CSS%E5%B8%83%E5%B1%80/"/>
      <url>/2018/12/11/CSS%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="本文主要包括以下内容："><a href="#本文主要包括以下内容：" class="headerlink" title="本文主要包括以下内容："></a>本文主要包括以下内容：</h2><ol><li>左右布局</li><li>左中右布局</li><li>水平居中</li><li>垂直居中</li><li>等其他小技巧</li></ol><h3 id="1、左右布局（两栏布局）"><a href="#1、左右布局（两栏布局）" class="headerlink" title="1、左右布局（两栏布局）"></a>1、左右布局（两栏布局）</h3><ul><li>两栏布局： <strong>一栏定宽，一栏自适应</strong>。</li><li>链接:<br><a href="http://js.jirengu.com/ruzogewubi/1/edit?html,css,output" target="_blank" rel="noopener">两栏布局</a></li></ul><h3 id="2、左中右布局-三栏布局"><a href="#2、左中右布局-三栏布局" class="headerlink" title="2、左中右布局(三栏布局)"></a>2、左中右布局(三栏布局)</h3><ul><li>三栏布局：<strong>两边定宽，然后中间的width是auto自适应内容</strong>。</li><li>链接:<br><a href="http://js.jirengu.com/dezilezuke/1/edit?html,css,output" target="_blank" rel="noopener">三栏布局</a></li></ul><h3 id="3、水平居中"><a href="#3、水平居中" class="headerlink" title="3、水平居中"></a>3、水平居中</h3><ul><li>flex实现水平居中: <strong>Flexbox布局自适应调整和分布一个容器里的项目布局，即使他们的大小是未知或者是动态的</strong>。</li><li>链接:<br><a href="http://js.jirengu.com/wisegaguco/1/edit?html,css,output" target="_blank" rel="noopener">flex水平居中</a></li></ul><h3 id="4、垂直居中"><a href="#4、垂直居中" class="headerlink" title="4、垂直居中"></a>4、垂直居中</h3><ul><li>绝对定位与负边距实现: <strong>利用绝对定位，将元素的top和left属性都设为50%，再利用margin边距，将元素回拉它本身高宽的一半，实现垂直居中。</strong></li><li>链接:<br><a href="http://js.jirengu.com/nolikenemi/1/edit?html,css,output" target="_blank" rel="noopener">绝对定位与负边距实现</a></li><li>绝对定位与margin: <strong>利用绝对定位与margin，但是无需知道被垂直居中元素的高和宽</strong>。</li><li>链接:<br><a href="http://js.jirengu.com/huzetituqu/1/edit" target="_blank" rel="noopener">绝对定位与margin</a></li></ul><h3 id="5、等其他小技巧"><a href="#5、等其他小技巧" class="headerlink" title="5、等其他小技巧"></a>5、等其他小技巧</h3><ul><li>水平垂直居中(flex布局)</li><li>链接<br><a href="http://js.jirengu.com/limoyefato/1/edit?html,css,output" target="_blank" rel="noopener">水平垂直居中flex布局</a></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>CSS</title>
      <link href="/2018/12/10/CSS/"/>
      <url>/2018/12/10/CSS/</url>
      
        <content type="html"><![CDATA[<h2 id="本文主要包括以下内容："><a href="#本文主要包括以下内容：" class="headerlink" title="本文主要包括以下内容："></a>本文主要包括以下内容：</h2><ol><li>高度是由什么决定的?</li><li>line-box 是啥?</li><li>box 是啥（盒模型）?</li><li>宽度是由什么决定的?</li><li>position 的 5 个取值</li><li>z-index</li></ol><h3 id="1、高度是由什么决定的"><a href="#1、高度是由什么决定的" class="headerlink" title="1、高度是由什么决定的?"></a>1、高度是由什么决定的?</h3><ul><li><strong>内联元素</strong> (自左往右,自动换行，但如果内联元素是一个很长的英文单词，则不会分开换行)<br><code>内联元素的高是由字体设计师决定</code> </li><li><strong>块级元素</strong> (从上往下，占据整行)<br><code>块级元素的高度由其内部文档流元素的高度总分决定的</code></li></ul><h3 id="2、line-box-是啥"><a href="#2、line-box-是啥" class="headerlink" title="2、line-box 是啥?"></a>2、line-box 是啥?</h3><ul><li>每一行称为一条Line Box，它又是由这一行的许多<strong>inline-box组成，它的高度可以直接由line-height决定</strong>，line boxes的高度垂直堆叠形成了containing box的高度，就是我们见到的div或是p标签之类的高度了。</li></ul><h3 id="3、box-是啥（盒模型）"><a href="#3、box-是啥（盒模型）" class="headerlink" title="3、box 是啥（盒模型）?"></a>3、box 是啥（盒模型）?</h3><ul><li>盒模型对比<br><img src="http://upload-images.jianshu.io/upload_images/6970717-2046f9172e7c0e58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="盒模型对比.png"><br><code>W3C标准中padding、border所占的空间不在width、height范围内，大家俗称的IE的盒模型width包括content尺寸＋padding＋border</code></li></ul><h3 id="4、宽度是由什么决定的"><a href="#4、宽度是由什么决定的" class="headerlink" title="4、宽度是由什么决定的?"></a>4、宽度是由什么决定的?</h3><ul><li><strong>行内元素</strong>的宽度是由它的<strong>内容</strong>决定的，行内元素不能设置宽高</li><li><strong>块级元素</strong>当没有设置宽度是<strong>默认100%宽</strong>，当设置了宽度是就是固定的宽度 </li></ul><h3 id="5、position-的-5-个取值"><a href="#5、position-的-5-个取值" class="headerlink" title="5、position 的 5 个取值"></a>5、position 的 5 个取值</h3><ul><li>sticky</li><li>absolute</li><li>fixed</li><li>relative</li><li>static</li></ul><h3 id="6、z-index"><a href="#6、z-index" class="headerlink" title="6、z-index"></a>6、z-index</h3><ul><li><strong>z-index 属性指定了一个具有定位属性的元素及其子代元素的 z-order。 当元素之间重叠的时候，z-order 决定哪一个元素覆盖在其余元素的上方显示。 通常来说 z-index 较大的元素会覆盖较小的一个。</strong></li><li>链接：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index" target="_blank" rel="noopener">z-index标签</a></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>HTML_Common</title>
      <link href="/2018/12/09/HTML-Common/"/>
      <url>/2018/12/09/HTML-Common/</url>
      
        <content type="html"><![CDATA[<h2 id="本文主要包括以下内容："><a href="#本文主要包括以下内容：" class="headerlink" title="本文主要包括以下内容："></a>本文主要包括以下内容：</h2><ol><li>iframe 标签</li><li>a 标签</li><li>form 标签</li><li>input / button标签</li><li>table 标签</li></ol><h3 id="1、iframe-标签"><a href="#1、iframe-标签" class="headerlink" title="1、iframe 标签"></a>1、iframe 标签</h3><ul><li>嵌套页面<br><code>&lt;iframe src=&quot;https://www.baidu.com&quot; name=&quot;xxx&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;</code></li><li>常用和<code>&lt;a&gt;</code>使用<br><code>&lt;a href=&quot;https://qq.com&quot; target=xxx&gt;</code></li></ul><h3 id="2、a-标签"><a href="#2、a-标签" class="headerlink" title="2、a 标签"></a>2、a 标签</h3><ul><li>跳转页面（<strong>HTTP GET 请求</strong>）</li><li>属性：</li><li>链接：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a" target="_blank" rel="noopener">a标签</a></li></ul><h3 id="3、form-标签"><a href="#3、form-标签" class="headerlink" title="3、form 标签"></a>3、form 标签</h3><ul><li>跳转页面（<strong>HTTP POST 请求</strong>）</li><li>属性：</li><li>链接：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/form" target="_blank" rel="noopener">form标签</a></li></ul><h3 id="4、input-button标签"><a href="#4、input-button标签" class="headerlink" title="4、input / button标签"></a>4、input / button标签</h3><ul><li><strong>区别</strong>：是否为「空标签」</li><li>input 的属性如：</li><li>链接：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input" target="_blank" rel="noopener">input标签</a></li></ul><blockquote><p><code>&lt;input type=&quot;text&quot;&gt;</code><br><code>&lt;input type=&quot;password&quot;&gt;</code><br><code>&lt;input type=&quot;submit&quot;&gt;</code><br><code>&lt;input type=&quot;checkbox&quot; value=&quot;xxx&quot;&gt;</code><br><code>&lt;input type=&quot;radio&quot; value=&quot;yyy&quot;&gt;</code></p></blockquote><ul><li>button 的属性如：</li><li>链接：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button" target="_blank" rel="noopener">button</a></li></ul><blockquote><p><code>&lt;button name=&quot;button&quot;&gt;Click me&lt;/button&gt;</code><br><code>&lt;button&gt;Click me&lt;/button&gt;</code></p></blockquote><h3 id="5、table-标签"><a href="#5、table-标签" class="headerlink" title="5、table 标签"></a>5、table 标签</h3><ul><li><strong>用于展示数据</strong></li><li>table 的属性：</li><li>链接：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/table" target="_blank" rel="noopener">table标签</a></li><li>table 实现标签:<br><code>tr --- table row</code>, <code>th --- table header cell</code>, <code>td --- table data cell</code></li><li><strong>知识点</strong>：<ul><li>空标签</li><li>可替换标签</li><li>全局属性</li><li>display 不止 3 种</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>HTML</title>
      <link href="/2018/12/08/HTML/"/>
      <url>/2018/12/08/HTML/</url>
      
        <content type="html"><![CDATA[<h2 id="本文主要包括以下内容："><a href="#本文主要包括以下内容：" class="headerlink" title="本文主要包括以下内容："></a>本文主要包括以下内容：</h2><ol><li>HTML 的版本</li><li>怎样理解 HTML 语义化</li><li>怎样理解内容与样式分离的原则</li><li>有哪些常见的meta标签</li><li>文档声明的作用?严格模式和混杂模式指什么?&lt;!doctype html&gt; 的作用?</li><li>浏览器乱码的原因是什么？如何解决?</li><li>常见的浏览器有哪些？什么内核？</li><li>列出常见的标签，并简单介绍这些标签用在什么场景</li></ol><h3 id="1、HTML-的版本"><a href="#1、HTML-的版本" class="headerlink" title="1、HTML 的版本"></a>1、HTML 的版本</h3><ul><li>HTML <code>超文本标记语言</code>（HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。</li><li>XML <code>可扩展标识语言</code>(The Extensible Markup Language)的简写，主要用于存储数据和结构。</li><li>XHTML <code>可扩展超文本标记语言</code> (The Extensible HyperText Markup Language)的缩写,基于XML，作用与HTML类似,目的就是实现HTML向XML的过渡。 </li></ul><h3 id="2、怎样理解-HTML-语义化"><a href="#2、怎样理解-HTML-语义化" class="headerlink" title="2、怎样理解 HTML 语义化"></a>2、怎样理解 HTML 语义化</h3><ul><li>语义化HTML是一种编写HTML的方式。</li><li>选择合适的标签、使用合理的代码结构，便于开发者阅读，同时让浏览器的爬虫和机器很好地解析。</li><li>语义化的好处:<ol><li>页面呈现出很好地<strong>内容结构、代码结构</strong>。</li><li><strong>用户体验好</strong>。</li><li>利于<strong>SEO优化</strong>。</li><li>方便其他设备<strong>解析</strong>来渲染网页。</li><li>便于<strong>团队开发和维护</strong>，语义化更具<strong>可读性</strong>。</li></ol></li></ul><h3 id="3、怎样理解内容与样式分离的原则"><a href="#3、怎样理解内容与样式分离的原则" class="headerlink" title="3、怎样理解内容与样式分离的原则"></a>3、怎样理解内容与样式分离的原则</h3><ul><li>在WEB开发中， 一个网页分为三部分：<code>Html——结构（内容）</code>，<code>css——表现（样式）</code>，<code>javascript——行为</code>。内容与样式分离，就是让内容的归 HTML, 样式归 CSS。同时，HTML 内不允许出现属性样式，尽量不要出现行内样式。</li><li>编码正确做法是HTML和CSS要分开使用，不要混着用。重点放在HTML的结构和语义化上，让HTML能提现页面结构或者内容,，然后进行 css 样式设置（即内容与样式分离） ，写JS的时候，尽量不要用JS去直接操作样式，而是通过给元素添加删除class来控制样式变化（即行为分离）。</li><li>分离原则的优点:<ol><li><strong>浏览器加载网页页面速度变快</strong>。分离原则下，大部分页面代码写在了CSS当中，页面体积容量变得更小。</li><li><strong>网页修改设计时，效率、省时</strong>。根据html标签内ID或class的标记，到CSS里找到相应的ID或class，可以快速替换指定位置的样式，不会破坏页面架构和其他部分的样式。</li><li><strong>典型的应用就是网页换肤</strong>。使用相同的 html 结构，不同的 CSS 样式。</li><li><strong>更好地被搜索引擎收录</strong>。基于内容与样式分离的原则，html的语义化就是首要考虑的,网页中语义化的标签代码就会更加适合搜索引擎。</li><li><strong>CSS样式的分离，它可以根据不同的浏览器，达到显示效果的统一</strong>。保证网页架构不变形的前提下，放心在不同浏览器渲染显示样式。</li></ol></li></ul><h3 id="4、有哪些常见的meta标签"><a href="#4、有哪些常见的meta标签" class="headerlink" title="4、有哪些常见的meta标签"></a>4、有哪些常见的meta标签</h3><ul><li><p>语言采用<strong>中文</strong><br><code>&lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;zh-CN&quot; /&gt;</code>       </p></li><li><p>编码格式：<strong>告诉给浏览器用什么方式来解析这页代码</strong><br>  <code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>       </p></li><li>如果支持Google Chrome Frame：GCF，则使用GCF渲染；如果系统安装ie8或以上版本，则使用最高版本ie渲染； 否则，这个设定可以忽略。 目的<strong>使内容在移动端上比较合理展示</strong>。<br>  <code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;</code>    </li><li>控制网页为全屏幕大小<br>  <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;</code></li><li>目的是方便<strong>SEO优化</strong>内容关键字搜索<br>  <code>&lt;meta name=&quot;keywords&quot; content=&quot;&quot;&gt;</code></li></ul><h3 id="5、文档声明的作用-严格模式和混杂模式指什么-lt-doctype-html-gt-的作用"><a href="#5、文档声明的作用-严格模式和混杂模式指什么-lt-doctype-html-gt-的作用" class="headerlink" title="5、文档声明的作用?严格模式和混杂模式指什么?&lt;!doctype html&gt; 的作用?"></a>5、文档声明的作用?严格模式和混杂模式指什么?&lt;!doctype html&gt; 的作用?</h3><ul><li>文档声明的作用  <p>文档声明目的是<strong>防止出现乱码</strong>情况。</p></li><li>严格模式和混杂模式指什么<br><strong>严格模式</strong>：又称标准模式，是指<strong>浏览器按照 W3C 标准解析代码</strong>。<br><strong>混杂模式</strong>：又称怪异模式或兼容模式，是指<strong>浏览器用自己的方式解析代码</strong>。<br>   <strong>区分</strong>    ：浏览器解析时到底使用严格模式还是混杂模式，与网页中的 <strong>DTD</strong> 直接相关。</li><li>关于&lt;!DOCTYPE html&gt;<ul><li>关于<doctype>声明叫做文件类型定义（DTD），声明的作用<strong>为了告诉浏览器该文件的类型。让浏览器解析器知道应该用哪个规范来解析文档</strong>。</doctype></li></ul></li></ul><h3 id="6、浏览器乱码的原因是什么？如何解决"><a href="#6、浏览器乱码的原因是什么？如何解决" class="headerlink" title="6、浏览器乱码的原因是什么？如何解决?"></a>6、浏览器乱码的原因是什么？如何解决?</h3><ul><li>html源代码内中文字内容与html编码不同造成。但无论是哪种情况造成乱码在网页开始时候都需要设置网页编码。</li><li>解决：<br>  <code>&lt;meta charset=&quot;utf-8&quot;&gt;</code></li></ul><h3 id="7、常见的浏览器有哪些？什么内核？"><a href="#7、常见的浏览器有哪些？什么内核？" class="headerlink" title="7、常见的浏览器有哪些？什么内核？"></a>7、常见的浏览器有哪些？什么内核？</h3><ul><li><p>浏览器</p><p>chrome浏览器、火狐浏览器（Mozilla Firefox）、IE浏览器、360极速浏览器、搜狗浏览器、猎豹极轻浏览器等。</p></li><li><p>内核<br>1、Trident(IE内核)；<br>2、Gecko(Firefox内核)；<br>3、Presto(Opera前内核) (已废弃)；<br>4、Webkit(Safari内核,Chrome内核原型,开源)。</p></li></ul><h3 id="8、列出常见的标签，并简单介绍这些标签用在什么场景"><a href="#8、列出常见的标签，并简单介绍这些标签用在什么场景" class="headerlink" title="8、列出常见的标签，并简单介绍这些标签用在什么场景"></a>8、列出常见的标签，并简单介绍这些标签用在什么场景</h3><ul><li><p><strong>注意点</strong><br>1、标签属性全小写;<br>2、标签要闭合、自闭合标签可以省略 /;<br>3、标题里不能有段落，段落里不能有标题;</p></li><li><p><code>h1~h6</code> 标题<br> </p><h1>代表页面最大的标题</h1><br> <h2>二级标题</h2><br> <h3>更弱的标题</h3><br> <h4>…</h4><br> <h5>…</h5><p></p> <h6>最小标题</h6></li><li><p><code>p</code>段落</p> <p>表示大段文字</p></li><li><p><code>a</code>链接，链到一个地址<br> &lt;a href=”<a href="http://www.google.com&quot;&quot;" target="_blank" rel="noopener">http://www.google.com&quot;&quot;</a> target=”_blank” title=”ABC”&gt;google.com<br> <a href="#">空</a><br> <a href="#about">定位ID标签about位置</a><br> <a href="/getCourse">链接路径地址</a></p></li><li><p><code>img</code>展示一张图片<br>   <img src="a.png" alt=""></p></li><li><p><code>div</code>语义为“一大块”，用于给页面划分区块，让结构更清晰</p>   <div id="header">…</div><br>   <div id="content">…</div><br>   <div id="footer">…</div></li><li><p><code>ul li</code></p><ol><li>ul: unsort list 无序列表</li><li>用于表示并列的内容</li><li>ul的直接子元素是li</li><li>可以嵌套<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=&quot;nav&quot;&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;关于&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;a href=&quot;#&quot;&gt;更多&lt;/a&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;联系&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;地址&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;·</span><br></pre></td></tr></table></figure></li></ol></li><li><p><code>ol li</code></p><ol><li>ol: order list 有序序列表 </li><li>用于表示带步骤或者编号的并列内容 </li><li>ol的直接子元素只能是li 可以嵌套</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;把大象关到冰箱的步骤&lt;/h2&gt;</span><br><span class="line">&lt;ol&gt;</span><br><span class="line">  &lt;li&gt;把大象变小&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;打开冰箱&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;把大象塞进去&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure><ul><li>dl dt dd用于展示一系列 “标题:内容… ”的场景</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dl&gt;</span><br><span class="line">    &lt;dt&gt;商品名称:&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;青花瓷&lt;/dd&gt;</span><br><span class="line">    &lt;dt&gt;特征:&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;白色&lt;/dd&gt;</span><br><span class="line">    &lt;dd&gt;圆口&lt;/dd&gt;</span><br><span class="line">    &lt;dt&gt;商品介绍&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;这是一个年代久远的瓷器，很贵，易碎&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure><ul><li><p><code>button</code>按钮</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button&gt;点我&lt;/button&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>strong em</code></p><ol><li>em 需要强调一下</li><li>strong 很重要、强调性更强<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;p&gt;优惠 &lt;strong&gt;100&lt;/strong&gt; 元&lt;/p&gt;</span><br><span class="line">&lt;p&gt;小谷 &lt;em&gt;2&lt;/em&gt; 岁了&lt;/p&gt;</span><br></pre></td></tr></table></figure></li></ol></li><li><p><code>iframe</code>用于嵌入一个页面 注意跨域操作问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;iframe src=&quot;http://www.google.com&quot; name=&quot;myPage&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;p&gt;&lt;a href=&quot;http://www.baidu.com&quot;&quot; target=&quot;myPage&quot;&gt;baidu.com&lt;/a&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>table</code>用于展示表格，不要用来做布局 thead tbody tfoot可省略，浏览器会自动添加 border-collapse: collapse;用于合并边框</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;th&gt;姓名&lt;/th&gt;</span><br><span class="line">  &lt;th&gt;年纪&lt;/th&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;td&gt;小明&lt;/td&gt;</span><br><span class="line">  &lt;td&gt;18&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;td&gt;小花&lt;/td&gt;</span><br><span class="line">  &lt;td&gt;20&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>HTTP</title>
      <link href="/2018/12/07/HTTP/"/>
      <url>/2018/12/07/HTTP/</url>
      
        <content type="html"><![CDATA[<h2 id="本文主要包括以下内容："><a href="#本文主要包括以下内容：" class="headerlink" title="本文主要包括以下内容："></a>本文主要包括以下内容：</h2><ol><li><p>HTTP是什么？</p></li><li><p>HTTP 请求包括哪些部分？</p></li><li><p>HTTP 响应包括哪些部分？</p></li><li><p>如何用Chrome开发者工具查看 HTTP 请求及请求的内容？</p></li><li><p>如何使用 curl 命令？</p></li></ol><h3 id="1、HTTP是什么"><a href="#1、HTTP是什么" class="headerlink" title="1、HTTP是什么?"></a>1、HTTP是什么?</h3><ul><li><p><code>HTTP</code> 全称：HyperText Transfer Protocol，即超文本传输协议<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">HTTP</a>的作用。</p></li><li><p><code>HTTP作用</code> : 指导浏览器和服务器之间进行沟通。</p></li></ul><h3 id="2、HTTP-请求包括哪些部分？"><a href="#2、HTTP-请求包括哪些部分？" class="headerlink" title="2、HTTP 请求包括哪些部分？"></a>2、HTTP 请求包括哪些部分？</h3><ul><li>HTTP请求主要包括四部分（第四部分可以为空），主要格式如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1 动词 路径 协议/版本</span><br><span class="line"></span><br><span class="line">2 Key1: value1</span><br><span class="line"></span><br><span class="line">2 Key2: value2</span><br><span class="line"></span><br><span class="line">2 Key3: value3</span><br><span class="line"></span><br><span class="line">2 Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">2 Host: www.baidu.com</span><br><span class="line"></span><br><span class="line">2 User-Agent: curl/7.54.0</span><br><span class="line"></span><br><span class="line">3 </span><br><span class="line"></span><br><span class="line">4 要上传的数据</span><br></pre></td></tr></table></figure></li></ul><h3 id="3、HTTP-响应包括哪些部分？"><a href="#3、HTTP-响应包括哪些部分？" class="headerlink" title="3、HTTP 响应包括哪些部分？"></a>3、HTTP 响应包括哪些部分？</h3><ul><li>HTTP响应主要包括四部分（第四部分可以为空），主要格式如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1 协议/版本号 状态码 状态解释</span><br><span class="line">2 Key1: value1</span><br><span class="line">2 Key2: value2</span><br><span class="line">2 Content-Length: 17931</span><br><span class="line">2 Content-Type: text/html</span><br><span class="line">3</span><br><span class="line">4 要下载的内容</span><br></pre></td></tr></table></figure></li></ul><h3 id="4、如何用Chrome开发者工具查看-HTTP-请求及响应的内容？"><a href="#4、如何用Chrome开发者工具查看-HTTP-请求及响应的内容？" class="headerlink" title="4、如何用Chrome开发者工具查看 HTTP 请求及响应的内容？"></a>4、如何用Chrome开发者工具查看 HTTP 请求及响应的内容？</h3><ul><li>eg：用<strong>Chrome</strong>发请求</li></ul><ol><li>打开 Network</li><li>地址栏输入网址</li><li>在 Network 点击，查看 request，点击「view source」</li><li>点击「view source」可查看请求的前三部分</li><li>如果有请求的第四部分，那么在 FormData 或 Payload 里面可以看到</li></ol><ul><li>用<strong>Chrome</strong>查看响应</li></ul><ol><li>打开 Network</li><li>输入网址</li><li>选中第一个响应</li><li>查看 Response Headers，点击「view source」</li><li>查看响应的前两部分</li><li>查看 Response 或者 Preview，你会看到响应的第 4 部分</li></ol><h3 id="5、如何使用-curl-命令？"><a href="#5、如何使用-curl-命令？" class="headerlink" title="5、如何使用 curl 命令？"></a>5、如何使用 curl 命令？</h3><ul><li><code>Curl</code>是Linux下一个很强大的http命令行工具。</li><li>curl的基本用途：创造一个请求，并得到响应，主要如下图：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -s -v -H &quot;Nola: xxx&quot; -- &quot;https://www.baidu.com&quot;</span><br><span class="line">请求内容：</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">User-Agent: curl/7.54.0</span><br><span class="line">Accept: */*</span><br><span class="line">Nola: xxx</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -s -v -H &quot;Nola: xxx&quot; -- &quot;https://www.baidu.com&quot;</span><br><span class="line">请求内容：</span><br><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">User-Agent: curl/7.54.0</span><br><span class="line">Accept: */*</span><br><span class="line">Nola: xxx</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -d &quot;1234567890&quot; -s -v -H &quot;Nola: xxx&quot; -- &quot;https://www.baidu.com&quot;</span><br><span class="line">请求内容：</span><br><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">User-Agent: curl/7.54.0</span><br><span class="line">Accept: */*</span><br><span class="line">Nola: xxx</span><br><span class="line">Content-Length: 10</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>开博大吉</title>
      <link href="/2018/12/07/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/"/>
      <url>/2018/12/07/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</url>
      
        <content type="html"><![CDATA[<h3 id="学习记录前端小知识"><a href="#学习记录前端小知识" class="headerlink" title="学习记录前端小知识"></a>学习记录前端小知识</h3>]]></content>
      
      
      
    </entry>
    
  
  
</search>
